{"ast":null,"code":"var ber = require('asn1').Ber;\n\nvar _ = require('../utils')._;\n\nvar PUBLIC_RSA_OID = '1.2.840.113549.1.1.1';\n\nvar utils = require('../utils');\n\nconst PRIVATE_OPENING_BOUNDARY = '-----BEGIN PRIVATE KEY-----';\nconst PRIVATE_CLOSING_BOUNDARY = '-----END PRIVATE KEY-----';\nconst PUBLIC_OPENING_BOUNDARY = '-----BEGIN PUBLIC KEY-----';\nconst PUBLIC_CLOSING_BOUNDARY = '-----END PUBLIC KEY-----';\nmodule.exports = {\n  privateExport: function (key, options) {\n    options = options || {};\n    var n = key.n.toBuffer();\n    var d = key.d.toBuffer();\n    var p = key.p.toBuffer();\n    var q = key.q.toBuffer();\n    var dmp1 = key.dmp1.toBuffer();\n    var dmq1 = key.dmq1.toBuffer();\n    var coeff = key.coeff.toBuffer();\n    var length = n.length + d.length + p.length + q.length + dmp1.length + dmq1.length + coeff.length + 512; // magic\n\n    var bodyWriter = new ber.Writer({\n      size: length\n    });\n    bodyWriter.startSequence();\n    bodyWriter.writeInt(0);\n    bodyWriter.writeBuffer(n, 2);\n    bodyWriter.writeInt(key.e);\n    bodyWriter.writeBuffer(d, 2);\n    bodyWriter.writeBuffer(p, 2);\n    bodyWriter.writeBuffer(q, 2);\n    bodyWriter.writeBuffer(dmp1, 2);\n    bodyWriter.writeBuffer(dmq1, 2);\n    bodyWriter.writeBuffer(coeff, 2);\n    bodyWriter.endSequence();\n    var writer = new ber.Writer({\n      size: length\n    });\n    writer.startSequence();\n    writer.writeInt(0);\n    writer.startSequence();\n    writer.writeOID(PUBLIC_RSA_OID);\n    writer.writeNull();\n    writer.endSequence();\n    writer.writeBuffer(bodyWriter.buffer, 4);\n    writer.endSequence();\n\n    if (options.type === 'der') {\n      return writer.buffer;\n    } else {\n      return PRIVATE_OPENING_BOUNDARY + '\\n' + utils.linebrk(writer.buffer.toString('base64'), 64) + '\\n' + PRIVATE_CLOSING_BOUNDARY;\n    }\n  },\n  privateImport: function (key, data, options) {\n    options = options || {};\n    var buffer;\n\n    if (options.type !== 'der') {\n      if (Buffer.isBuffer(data)) {\n        data = data.toString('utf8');\n      }\n\n      if (_.isString(data)) {\n        var pem = utils.trimSurroundingText(data, PRIVATE_OPENING_BOUNDARY, PRIVATE_CLOSING_BOUNDARY).replace('-----END PRIVATE KEY-----', '').replace(/\\s+|\\n\\r|\\n|\\r$/gm, '');\n        buffer = Buffer.from(pem, 'base64');\n      } else {\n        throw Error('Unsupported key format');\n      }\n    } else if (Buffer.isBuffer(data)) {\n      buffer = data;\n    } else {\n      throw Error('Unsupported key format');\n    }\n\n    var reader = new ber.Reader(buffer);\n    reader.readSequence();\n    reader.readInt(0);\n    var header = new ber.Reader(reader.readString(0x30, true));\n\n    if (header.readOID(0x06, true) !== PUBLIC_RSA_OID) {\n      throw Error('Invalid Public key format');\n    }\n\n    var body = new ber.Reader(reader.readString(0x04, true));\n    body.readSequence();\n    body.readString(2, true); // just zero\n\n    key.setPrivate(body.readString(2, true), // modulus\n    body.readString(2, true), // publicExponent\n    body.readString(2, true), // privateExponent\n    body.readString(2, true), // prime1\n    body.readString(2, true), // prime2\n    body.readString(2, true), // exponent1 -- d mod (p1)\n    body.readString(2, true), // exponent2 -- d mod (q-1)\n    body.readString(2, true) // coefficient -- (inverse of q) mod p\n    );\n  },\n  publicExport: function (key, options) {\n    options = options || {};\n    var n = key.n.toBuffer();\n    var length = n.length + 512; // magic\n\n    var bodyWriter = new ber.Writer({\n      size: length\n    });\n    bodyWriter.writeByte(0);\n    bodyWriter.startSequence();\n    bodyWriter.writeBuffer(n, 2);\n    bodyWriter.writeInt(key.e);\n    bodyWriter.endSequence();\n    var writer = new ber.Writer({\n      size: length\n    });\n    writer.startSequence();\n    writer.startSequence();\n    writer.writeOID(PUBLIC_RSA_OID);\n    writer.writeNull();\n    writer.endSequence();\n    writer.writeBuffer(bodyWriter.buffer, 3);\n    writer.endSequence();\n\n    if (options.type === 'der') {\n      return writer.buffer;\n    } else {\n      return PUBLIC_OPENING_BOUNDARY + '\\n' + utils.linebrk(writer.buffer.toString('base64'), 64) + '\\n' + PUBLIC_CLOSING_BOUNDARY;\n    }\n  },\n  publicImport: function (key, data, options) {\n    options = options || {};\n    var buffer;\n\n    if (options.type !== 'der') {\n      if (Buffer.isBuffer(data)) {\n        data = data.toString('utf8');\n      }\n\n      if (_.isString(data)) {\n        var pem = utils.trimSurroundingText(data, PUBLIC_OPENING_BOUNDARY, PUBLIC_CLOSING_BOUNDARY).replace(/\\s+|\\n\\r|\\n|\\r$/gm, '');\n        buffer = Buffer.from(pem, 'base64');\n      }\n    } else if (Buffer.isBuffer(data)) {\n      buffer = data;\n    } else {\n      throw Error('Unsupported key format');\n    }\n\n    var reader = new ber.Reader(buffer);\n    reader.readSequence();\n    var header = new ber.Reader(reader.readString(0x30, true));\n\n    if (header.readOID(0x06, true) !== PUBLIC_RSA_OID) {\n      throw Error('Invalid Public key format');\n    }\n\n    var body = new ber.Reader(reader.readString(0x03, true));\n    body.readByte();\n    body.readSequence();\n    key.setPublic(body.readString(0x02, true), // modulus\n    body.readString(0x02, true) // publicExponent\n    );\n  },\n\n  /**\n   * Trying autodetect and import key\n   * @param key\n   * @param data\n   */\n  autoImport: function (key, data) {\n    if (/^[\\S\\s]*-----BEGIN PRIVATE KEY-----\\s*(?=(([A-Za-z0-9+/=]+\\s*)+))\\1-----END PRIVATE KEY-----[\\S\\s]*$/g.test(data)) {\n      module.exports.privateImport(key, data);\n      return true;\n    }\n\n    if (/^[\\S\\s]*-----BEGIN PUBLIC KEY-----\\s*(?=(([A-Za-z0-9+/=]+\\s*)+))\\1-----END PUBLIC KEY-----[\\S\\s]*$/g.test(data)) {\n      module.exports.publicImport(key, data);\n      return true;\n    }\n\n    return false;\n  }\n};","map":{"version":3,"sources":["C:/Users/Zaman/zaman/RSA/front/node_modules/node-rsa/src/formats/pkcs8.js"],"names":["ber","require","Ber","_","PUBLIC_RSA_OID","utils","PRIVATE_OPENING_BOUNDARY","PRIVATE_CLOSING_BOUNDARY","PUBLIC_OPENING_BOUNDARY","PUBLIC_CLOSING_BOUNDARY","module","exports","privateExport","key","options","n","toBuffer","d","p","q","dmp1","dmq1","coeff","length","bodyWriter","Writer","size","startSequence","writeInt","writeBuffer","e","endSequence","writer","writeOID","writeNull","buffer","type","linebrk","toString","privateImport","data","Buffer","isBuffer","isString","pem","trimSurroundingText","replace","from","Error","reader","Reader","readSequence","readInt","header","readString","readOID","body","setPrivate","publicExport","writeByte","publicImport","readByte","setPublic","autoImport","test"],"mappings":"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","sourcesContent":["var ber = require('asn1').Ber;\nvar _ = require('../utils')._;\nvar PUBLIC_RSA_OID = '1.2.840.113549.1.1.1';\nvar utils = require('../utils');\n\nconst PRIVATE_OPENING_BOUNDARY = '-----BEGIN PRIVATE KEY-----';\nconst PRIVATE_CLOSING_BOUNDARY = '-----END PRIVATE KEY-----';\n\nconst PUBLIC_OPENING_BOUNDARY = '-----BEGIN PUBLIC KEY-----';\nconst PUBLIC_CLOSING_BOUNDARY = '-----END PUBLIC KEY-----';\n\nmodule.exports = {\n    privateExport: function (key, options) {\n        options = options || {};\n\n        var n = key.n.toBuffer();\n        var d = key.d.toBuffer();\n        var p = key.p.toBuffer();\n        var q = key.q.toBuffer();\n        var dmp1 = key.dmp1.toBuffer();\n        var dmq1 = key.dmq1.toBuffer();\n        var coeff = key.coeff.toBuffer();\n\n        var length = n.length + d.length + p.length + q.length + dmp1.length + dmq1.length + coeff.length + 512; // magic\n        var bodyWriter = new ber.Writer({size: length});\n\n        bodyWriter.startSequence();\n        bodyWriter.writeInt(0);\n        bodyWriter.writeBuffer(n, 2);\n        bodyWriter.writeInt(key.e);\n        bodyWriter.writeBuffer(d, 2);\n        bodyWriter.writeBuffer(p, 2);\n        bodyWriter.writeBuffer(q, 2);\n        bodyWriter.writeBuffer(dmp1, 2);\n        bodyWriter.writeBuffer(dmq1, 2);\n        bodyWriter.writeBuffer(coeff, 2);\n        bodyWriter.endSequence();\n\n        var writer = new ber.Writer({size: length});\n        writer.startSequence();\n        writer.writeInt(0);\n        writer.startSequence();\n        writer.writeOID(PUBLIC_RSA_OID);\n        writer.writeNull();\n        writer.endSequence();\n        writer.writeBuffer(bodyWriter.buffer, 4);\n        writer.endSequence();\n\n        if (options.type === 'der') {\n            return writer.buffer;\n        } else {\n            return PRIVATE_OPENING_BOUNDARY + '\\n' + utils.linebrk(writer.buffer.toString('base64'), 64) + '\\n' + PRIVATE_CLOSING_BOUNDARY;\n        }\n    },\n\n    privateImport: function (key, data, options) {\n        options = options || {};\n        var buffer;\n\n        if (options.type !== 'der') {\n            if (Buffer.isBuffer(data)) {\n                data = data.toString('utf8');\n            }\n\n            if (_.isString(data)) {\n                var pem = utils.trimSurroundingText(data, PRIVATE_OPENING_BOUNDARY, PRIVATE_CLOSING_BOUNDARY)\n                    .replace('-----END PRIVATE KEY-----', '')\n                    .replace(/\\s+|\\n\\r|\\n|\\r$/gm, '');\n                buffer = Buffer.from(pem, 'base64');\n            } else {\n                throw Error('Unsupported key format');\n            }\n        } else if (Buffer.isBuffer(data)) {\n            buffer = data;\n        } else {\n            throw Error('Unsupported key format');\n        }\n\n        var reader = new ber.Reader(buffer);\n        reader.readSequence();\n        reader.readInt(0);\n        var header = new ber.Reader(reader.readString(0x30, true));\n\n        if (header.readOID(0x06, true) !== PUBLIC_RSA_OID) {\n            throw Error('Invalid Public key format');\n        }\n\n        var body = new ber.Reader(reader.readString(0x04, true));\n        body.readSequence();\n        body.readString(2, true); // just zero\n        key.setPrivate(\n            body.readString(2, true),  // modulus\n            body.readString(2, true),  // publicExponent\n            body.readString(2, true),  // privateExponent\n            body.readString(2, true),  // prime1\n            body.readString(2, true),  // prime2\n            body.readString(2, true),  // exponent1 -- d mod (p1)\n            body.readString(2, true),  // exponent2 -- d mod (q-1)\n            body.readString(2, true)   // coefficient -- (inverse of q) mod p\n        );\n    },\n\n    publicExport: function (key, options) {\n        options = options || {};\n\n        var n = key.n.toBuffer();\n        var length = n.length + 512; // magic\n\n        var bodyWriter = new ber.Writer({size: length});\n        bodyWriter.writeByte(0);\n        bodyWriter.startSequence();\n        bodyWriter.writeBuffer(n, 2);\n        bodyWriter.writeInt(key.e);\n        bodyWriter.endSequence();\n\n        var writer = new ber.Writer({size: length});\n        writer.startSequence();\n        writer.startSequence();\n        writer.writeOID(PUBLIC_RSA_OID);\n        writer.writeNull();\n        writer.endSequence();\n        writer.writeBuffer(bodyWriter.buffer, 3);\n        writer.endSequence();\n\n        if (options.type === 'der') {\n            return writer.buffer;\n        } else {\n            return PUBLIC_OPENING_BOUNDARY + '\\n' + utils.linebrk(writer.buffer.toString('base64'), 64) + '\\n' + PUBLIC_CLOSING_BOUNDARY;\n        }\n    },\n\n    publicImport: function (key, data, options) {\n        options = options || {};\n        var buffer;\n\n        if (options.type !== 'der') {\n            if (Buffer.isBuffer(data)) {\n                data = data.toString('utf8');\n            }\n\n            if (_.isString(data)) {\n                var pem = utils.trimSurroundingText(data, PUBLIC_OPENING_BOUNDARY, PUBLIC_CLOSING_BOUNDARY)\n                    .replace(/\\s+|\\n\\r|\\n|\\r$/gm, '');\n                buffer = Buffer.from(pem, 'base64');\n            }\n        } else if (Buffer.isBuffer(data)) {\n            buffer = data;\n        } else {\n            throw Error('Unsupported key format');\n        }\n\n        var reader = new ber.Reader(buffer);\n        reader.readSequence();\n        var header = new ber.Reader(reader.readString(0x30, true));\n\n        if (header.readOID(0x06, true) !== PUBLIC_RSA_OID) {\n            throw Error('Invalid Public key format');\n        }\n\n        var body = new ber.Reader(reader.readString(0x03, true));\n        body.readByte();\n        body.readSequence();\n        key.setPublic(\n            body.readString(0x02, true), // modulus\n            body.readString(0x02, true)  // publicExponent\n        );\n    },\n\n    /**\n     * Trying autodetect and import key\n     * @param key\n     * @param data\n     */\n    autoImport: function (key, data) {\n        if (/^[\\S\\s]*-----BEGIN PRIVATE KEY-----\\s*(?=(([A-Za-z0-9+/=]+\\s*)+))\\1-----END PRIVATE KEY-----[\\S\\s]*$/g.test(data)) {\n            module.exports.privateImport(key, data);\n            return true;\n        }\n\n        if (/^[\\S\\s]*-----BEGIN PUBLIC KEY-----\\s*(?=(([A-Za-z0-9+/=]+\\s*)+))\\1-----END PUBLIC KEY-----[\\S\\s]*$/g.test(data)) {\n            module.exports.publicImport(key, data);\n            return true;\n        }\n\n        return false;\n    }\n};\n"]},"metadata":{},"sourceType":"script"}