{"ast":null,"code":"var _ = require(\"../utils\")._;\n\nvar utils = require(\"../utils\");\n\nvar BigInteger = require(\"../libs/jsbn\");\n\nconst PRIVATE_OPENING_BOUNDARY = \"-----BEGIN OPENSSH PRIVATE KEY-----\";\nconst PRIVATE_CLOSING_BOUNDARY = \"-----END OPENSSH PRIVATE KEY-----\";\nmodule.exports = {\n  privateExport: function (key, options) {\n    const nbuf = key.n.toBuffer();\n    let ebuf = Buffer.alloc(4);\n    ebuf.writeUInt32BE(key.e, 0); //Slice leading zeroes\n\n    while (ebuf[0] === 0) ebuf = ebuf.slice(1);\n\n    const dbuf = key.d.toBuffer();\n    const coeffbuf = key.coeff.toBuffer();\n    const pbuf = key.p.toBuffer();\n    const qbuf = key.q.toBuffer();\n    let commentbuf;\n\n    if (typeof key.sshcomment !== \"undefined\") {\n      commentbuf = Buffer.from(key.sshcomment);\n    } else {\n      commentbuf = Buffer.from([]);\n    }\n\n    const pubkeyLength = 11 + // 32bit length, 'ssh-rsa'\n    4 + ebuf.byteLength + 4 + nbuf.byteLength;\n    const privateKeyLength = 8 + //64bit unused checksum\n    11 + // 32bit length, 'ssh-rsa'\n    4 + nbuf.byteLength + 4 + ebuf.byteLength + 4 + dbuf.byteLength + 4 + coeffbuf.byteLength + 4 + pbuf.byteLength + 4 + qbuf.byteLength + 4 + commentbuf.byteLength;\n    let length = 15 + //openssh-key-v1,0x00,\n    16 + // 2*(32bit length, 'none')\n    4 + // 32bit length, empty string\n    4 + // 32bit number of keys\n    4 + // 32bit pubkey length\n    pubkeyLength + 4 + //32bit private+checksum+comment+padding length\n    privateKeyLength;\n    const paddingLength = Math.ceil(privateKeyLength / 8) * 8 - privateKeyLength;\n    length += paddingLength;\n    const buf = Buffer.alloc(length);\n    const writer = {\n      buf: buf,\n      off: 0\n    };\n    buf.write(\"openssh-key-v1\", \"utf8\");\n    buf.writeUInt8(0, 14);\n    writer.off += 15;\n    writeOpenSSHKeyString(writer, Buffer.from(\"none\"));\n    writeOpenSSHKeyString(writer, Buffer.from(\"none\"));\n    writeOpenSSHKeyString(writer, Buffer.from(\"\"));\n    writer.off = writer.buf.writeUInt32BE(1, writer.off);\n    writer.off = writer.buf.writeUInt32BE(pubkeyLength, writer.off);\n    writeOpenSSHKeyString(writer, Buffer.from(\"ssh-rsa\"));\n    writeOpenSSHKeyString(writer, ebuf);\n    writeOpenSSHKeyString(writer, nbuf);\n    writer.off = writer.buf.writeUInt32BE(length - 47 - pubkeyLength, writer.off);\n    writer.off += 8;\n    writeOpenSSHKeyString(writer, Buffer.from(\"ssh-rsa\"));\n    writeOpenSSHKeyString(writer, nbuf);\n    writeOpenSSHKeyString(writer, ebuf);\n    writeOpenSSHKeyString(writer, dbuf);\n    writeOpenSSHKeyString(writer, coeffbuf);\n    writeOpenSSHKeyString(writer, pbuf);\n    writeOpenSSHKeyString(writer, qbuf);\n    writeOpenSSHKeyString(writer, commentbuf);\n    let pad = 0x01;\n\n    while (writer.off < length) {\n      writer.off = writer.buf.writeUInt8(pad++, writer.off);\n    }\n\n    if (options.type === \"der\") {\n      return writer.buf;\n    } else {\n      return PRIVATE_OPENING_BOUNDARY + \"\\n\" + utils.linebrk(buf.toString(\"base64\"), 70) + \"\\n\" + PRIVATE_CLOSING_BOUNDARY + \"\\n\";\n    }\n  },\n  privateImport: function (key, data, options) {\n    options = options || {};\n    var buffer;\n\n    if (options.type !== \"der\") {\n      if (Buffer.isBuffer(data)) {\n        data = data.toString(\"utf8\");\n      }\n\n      if (_.isString(data)) {\n        var pem = utils.trimSurroundingText(data, PRIVATE_OPENING_BOUNDARY, PRIVATE_CLOSING_BOUNDARY).replace(/\\s+|\\n\\r|\\n|\\r$/gm, \"\");\n        buffer = Buffer.from(pem, \"base64\");\n      } else {\n        throw Error(\"Unsupported key format\");\n      }\n    } else if (Buffer.isBuffer(data)) {\n      buffer = data;\n    } else {\n      throw Error(\"Unsupported key format\");\n    }\n\n    const reader = {\n      buf: buffer,\n      off: 0\n    };\n    if (buffer.slice(0, 14).toString(\"ascii\") !== \"openssh-key-v1\") throw \"Invalid file format.\";\n    reader.off += 15; //ciphername\n\n    if (readOpenSSHKeyString(reader).toString(\"ascii\") !== \"none\") throw Error(\"Unsupported key type\"); //kdfname\n\n    if (readOpenSSHKeyString(reader).toString(\"ascii\") !== \"none\") throw Error(\"Unsupported key type\"); //kdf\n\n    if (readOpenSSHKeyString(reader).toString(\"ascii\") !== \"\") throw Error(\"Unsupported key type\"); //keynum\n\n    reader.off += 4; //sshpublength\n\n    reader.off += 4; //keytype\n\n    if (readOpenSSHKeyString(reader).toString(\"ascii\") !== \"ssh-rsa\") throw Error(\"Unsupported key type\");\n    readOpenSSHKeyString(reader);\n    readOpenSSHKeyString(reader);\n    reader.off += 12;\n    if (readOpenSSHKeyString(reader).toString(\"ascii\") !== \"ssh-rsa\") throw Error(\"Unsupported key type\");\n    const n = readOpenSSHKeyString(reader);\n    const e = readOpenSSHKeyString(reader);\n    const d = readOpenSSHKeyString(reader);\n    const coeff = readOpenSSHKeyString(reader);\n    const p = readOpenSSHKeyString(reader);\n    const q = readOpenSSHKeyString(reader); //Calculate missing values\n\n    const dint = new BigInteger(d);\n    const qint = new BigInteger(q);\n    const pint = new BigInteger(p);\n    const dp = dint.mod(pint.subtract(BigInteger.ONE));\n    const dq = dint.mod(qint.subtract(BigInteger.ONE));\n    key.setPrivate(n, // modulus\n    e, // publicExponent\n    d, // privateExponent\n    p, // prime1\n    q, // prime2\n    dp.toBuffer(), // exponent1 -- d mod (p1)\n    dq.toBuffer(), // exponent2 -- d mod (q-1)\n    coeff // coefficient -- (inverse of q) mod p\n    );\n    key.sshcomment = readOpenSSHKeyString(reader).toString(\"ascii\");\n  },\n  publicExport: function (key, options) {\n    let ebuf = Buffer.alloc(4);\n    ebuf.writeUInt32BE(key.e, 0); //Slice leading zeroes\n\n    while (ebuf[0] === 0) ebuf = ebuf.slice(1);\n\n    const nbuf = key.n.toBuffer();\n    const buf = Buffer.alloc(ebuf.byteLength + 4 + nbuf.byteLength + 4 + \"ssh-rsa\".length + 4);\n    const writer = {\n      buf: buf,\n      off: 0\n    };\n    writeOpenSSHKeyString(writer, Buffer.from(\"ssh-rsa\"));\n    writeOpenSSHKeyString(writer, ebuf);\n    writeOpenSSHKeyString(writer, nbuf);\n    let comment = key.sshcomment || \"\";\n\n    if (options.type === \"der\") {\n      return writer.buf;\n    } else {\n      return \"ssh-rsa \" + buf.toString(\"base64\") + \" \" + comment + \"\\n\";\n    }\n  },\n  publicImport: function (key, data, options) {\n    options = options || {};\n    var buffer;\n\n    if (options.type !== \"der\") {\n      if (Buffer.isBuffer(data)) {\n        data = data.toString(\"utf8\");\n      }\n\n      if (_.isString(data)) {\n        if (data.substring(0, 8) !== \"ssh-rsa \") throw Error(\"Unsupported key format\");\n        let pemEnd = data.indexOf(\" \", 8); //Handle keys with no comment\n\n        if (pemEnd === -1) {\n          pemEnd = data.length;\n        } else {\n          key.sshcomment = data.substring(pemEnd + 1).replace(/\\s+|\\n\\r|\\n|\\r$/gm, \"\");\n        }\n\n        const pem = data.substring(8, pemEnd).replace(/\\s+|\\n\\r|\\n|\\r$/gm, \"\");\n        buffer = Buffer.from(pem, \"base64\");\n      } else {\n        throw Error(\"Unsupported key format\");\n      }\n    } else if (Buffer.isBuffer(data)) {\n      buffer = data;\n    } else {\n      throw Error(\"Unsupported key format\");\n    }\n\n    const reader = {\n      buf: buffer,\n      off: 0\n    };\n    const type = readOpenSSHKeyString(reader).toString(\"ascii\");\n    if (type !== \"ssh-rsa\") throw Error(\"Invalid key type: \" + type);\n    const e = readOpenSSHKeyString(reader);\n    const n = readOpenSSHKeyString(reader);\n    key.setPublic(n, e);\n  },\n\n  /**\n   * Trying autodetect and import key\n   * @param key\n   * @param data\n   */\n  autoImport: function (key, data) {\n    // [\\S\\s]* matches zero or more of any character\n    if (/^[\\S\\s]*-----BEGIN OPENSSH PRIVATE KEY-----\\s*(?=(([A-Za-z0-9+/=]+\\s*)+))\\1-----END OPENSSH PRIVATE KEY-----[\\S\\s]*$/g.test(data)) {\n      module.exports.privateImport(key, data);\n      return true;\n    }\n\n    if (/^[\\S\\s]*ssh-rsa \\s*(?=(([A-Za-z0-9+/=]+\\s*)+))\\1[\\S\\s]*$/g.test(data)) {\n      module.exports.publicImport(key, data);\n      return true;\n    }\n\n    return false;\n  }\n};\n\nfunction readOpenSSHKeyString(reader) {\n  const len = reader.buf.readInt32BE(reader.off);\n  reader.off += 4;\n  const res = reader.buf.slice(reader.off, reader.off + len);\n  reader.off += len;\n  return res;\n}\n\nfunction writeOpenSSHKeyString(writer, data) {\n  writer.buf.writeInt32BE(data.byteLength, writer.off);\n  writer.off += 4;\n  writer.off += data.copy(writer.buf, writer.off);\n}","map":{"version":3,"sources":["C:/Users/Zaman/zaman/RSA/front/node_modules/node-rsa/src/formats/openssh.js"],"names":["_","require","utils","BigInteger","PRIVATE_OPENING_BOUNDARY","PRIVATE_CLOSING_BOUNDARY","module","exports","privateExport","key","options","nbuf","n","toBuffer","ebuf","Buffer","alloc","writeUInt32BE","e","slice","dbuf","d","coeffbuf","coeff","pbuf","p","qbuf","q","commentbuf","sshcomment","from","pubkeyLength","byteLength","privateKeyLength","length","paddingLength","Math","ceil","buf","writer","off","write","writeUInt8","writeOpenSSHKeyString","pad","type","linebrk","toString","privateImport","data","buffer","isBuffer","isString","pem","trimSurroundingText","replace","Error","reader","readOpenSSHKeyString","dint","qint","pint","dp","mod","subtract","ONE","dq","setPrivate","publicExport","comment","publicImport","substring","pemEnd","indexOf","setPublic","autoImport","test","len","readInt32BE","res","writeInt32BE","copy"],"mappings":"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","sourcesContent":["var _ = require(\"../utils\")._;\nvar utils = require(\"../utils\");\nvar BigInteger = require(\"../libs/jsbn\");\n\nconst PRIVATE_OPENING_BOUNDARY = \"-----BEGIN OPENSSH PRIVATE KEY-----\";\nconst PRIVATE_CLOSING_BOUNDARY = \"-----END OPENSSH PRIVATE KEY-----\";\n\nmodule.exports = {\n    privateExport: function (key, options) {\n        const nbuf = key.n.toBuffer();\n\n        let ebuf = Buffer.alloc(4)\n        ebuf.writeUInt32BE(key.e, 0);\n        //Slice leading zeroes\n        while (ebuf[0] === 0) ebuf = ebuf.slice(1);\n\n        const dbuf = key.d.toBuffer();\n        const coeffbuf = key.coeff.toBuffer();\n        const pbuf = key.p.toBuffer();\n        const qbuf = key.q.toBuffer();\n        let commentbuf;\n        if (typeof key.sshcomment !== \"undefined\") {\n            commentbuf = Buffer.from(key.sshcomment);\n        } else {\n            commentbuf = Buffer.from([]);\n        }\n\n        const pubkeyLength =\n            11 + // 32bit length, 'ssh-rsa'\n            4 + ebuf.byteLength +\n            4 + nbuf.byteLength;\n\n        const privateKeyLength =\n            8 + //64bit unused checksum\n            11 + // 32bit length, 'ssh-rsa'\n            4 + nbuf.byteLength +\n            4 + ebuf.byteLength +\n            4 + dbuf.byteLength +\n            4 + coeffbuf.byteLength +\n            4 + pbuf.byteLength +\n            4 + qbuf.byteLength +\n            4 + commentbuf.byteLength;\n\n        let length =\n            15 + //openssh-key-v1,0x00,\n            16 + // 2*(32bit length, 'none')\n            4 + // 32bit length, empty string\n            4 + // 32bit number of keys\n            4 + // 32bit pubkey length\n            pubkeyLength +\n            4 + //32bit private+checksum+comment+padding length\n            privateKeyLength;\n\n        const paddingLength = Math.ceil(privateKeyLength / 8) * 8 - privateKeyLength;\n        length += paddingLength;\n\n        const buf = Buffer.alloc(length);\n        const writer = {buf: buf, off: 0};\n        buf.write(\"openssh-key-v1\", \"utf8\");\n        buf.writeUInt8(0, 14);\n        writer.off += 15;\n\n        writeOpenSSHKeyString(writer, Buffer.from(\"none\"));\n        writeOpenSSHKeyString(writer, Buffer.from(\"none\"));\n        writeOpenSSHKeyString(writer, Buffer.from(\"\"));\n\n        writer.off = writer.buf.writeUInt32BE(1, writer.off);\n        writer.off = writer.buf.writeUInt32BE(pubkeyLength, writer.off);\n\n        writeOpenSSHKeyString(writer, Buffer.from(\"ssh-rsa\"));\n        writeOpenSSHKeyString(writer, ebuf);\n        writeOpenSSHKeyString(writer, nbuf);\n\n        writer.off = writer.buf.writeUInt32BE(\n            length - 47 - pubkeyLength,\n            writer.off\n        );\n        writer.off += 8;\n\n        writeOpenSSHKeyString(writer, Buffer.from(\"ssh-rsa\"));\n        writeOpenSSHKeyString(writer, nbuf);\n        writeOpenSSHKeyString(writer, ebuf);\n        writeOpenSSHKeyString(writer, dbuf);\n        writeOpenSSHKeyString(writer, coeffbuf);\n        writeOpenSSHKeyString(writer, pbuf);\n        writeOpenSSHKeyString(writer, qbuf);\n        writeOpenSSHKeyString(writer, commentbuf);\n\n        let pad = 0x01;\n        while (writer.off < length) {\n            writer.off = writer.buf.writeUInt8(pad++, writer.off);\n        }\n\n        if (options.type === \"der\") {\n            return writer.buf\n        } else {\n            return PRIVATE_OPENING_BOUNDARY + \"\\n\" + utils.linebrk(buf.toString(\"base64\"), 70) + \"\\n\" + PRIVATE_CLOSING_BOUNDARY + \"\\n\";\n        }\n    },\n\n    privateImport: function (key, data, options) {\n        options = options || {};\n        var buffer;\n\n        if (options.type !== \"der\") {\n            if (Buffer.isBuffer(data)) {\n                data = data.toString(\"utf8\");\n            }\n\n            if (_.isString(data)) {\n                var pem = utils.trimSurroundingText(data, PRIVATE_OPENING_BOUNDARY, PRIVATE_CLOSING_BOUNDARY)\n                    .replace(/\\s+|\\n\\r|\\n|\\r$/gm, \"\");\n                buffer = Buffer.from(pem, \"base64\");\n            } else {\n                throw Error(\"Unsupported key format\");\n            }\n        } else if (Buffer.isBuffer(data)) {\n            buffer = data;\n        } else {\n            throw Error(\"Unsupported key format\");\n        }\n\n        const reader = {buf: buffer, off: 0};\n\n        if (buffer.slice(0, 14).toString(\"ascii\") !== \"openssh-key-v1\")\n            throw \"Invalid file format.\";\n\n        reader.off += 15;\n\n        //ciphername\n        if (readOpenSSHKeyString(reader).toString(\"ascii\") !== \"none\")\n            throw Error(\"Unsupported key type\");\n        //kdfname\n        if (readOpenSSHKeyString(reader).toString(\"ascii\") !== \"none\")\n            throw Error(\"Unsupported key type\");\n        //kdf\n        if (readOpenSSHKeyString(reader).toString(\"ascii\") !== \"\")\n            throw Error(\"Unsupported key type\");\n        //keynum\n        reader.off += 4;\n\n        //sshpublength\n        reader.off += 4;\n\n        //keytype\n        if (readOpenSSHKeyString(reader).toString(\"ascii\") !== \"ssh-rsa\")\n            throw Error(\"Unsupported key type\");\n        readOpenSSHKeyString(reader);\n        readOpenSSHKeyString(reader);\n\n        reader.off += 12;\n        if (readOpenSSHKeyString(reader).toString(\"ascii\") !== \"ssh-rsa\")\n            throw Error(\"Unsupported key type\");\n\n        const n = readOpenSSHKeyString(reader);\n        const e = readOpenSSHKeyString(reader);\n        const d = readOpenSSHKeyString(reader);\n        const coeff = readOpenSSHKeyString(reader);\n        const p = readOpenSSHKeyString(reader);\n        const q = readOpenSSHKeyString(reader);\n\n        //Calculate missing values\n        const dint = new BigInteger(d);\n        const qint = new BigInteger(q);\n        const pint = new BigInteger(p);\n        const dp = dint.mod(pint.subtract(BigInteger.ONE));\n        const dq = dint.mod(qint.subtract(BigInteger.ONE));\n\n        key.setPrivate(\n            n,  // modulus\n            e,  // publicExponent\n            d,  // privateExponent\n            p,  // prime1\n            q,  // prime2\n            dp.toBuffer(),  // exponent1 -- d mod (p1)\n            dq.toBuffer(),  // exponent2 -- d mod (q-1)\n            coeff  // coefficient -- (inverse of q) mod p\n        );\n\n        key.sshcomment = readOpenSSHKeyString(reader).toString(\"ascii\");\n    },\n\n    publicExport: function (key, options) {\n        let ebuf = Buffer.alloc(4)\n        ebuf.writeUInt32BE(key.e, 0);\n        //Slice leading zeroes\n        while (ebuf[0] === 0) ebuf = ebuf.slice(1);\n        const nbuf = key.n.toBuffer();\n        const buf = Buffer.alloc(\n            ebuf.byteLength + 4 +\n            nbuf.byteLength + 4 +\n            \"ssh-rsa\".length + 4\n        );\n\n        const writer = {buf: buf, off: 0};\n        writeOpenSSHKeyString(writer, Buffer.from(\"ssh-rsa\"));\n        writeOpenSSHKeyString(writer, ebuf);\n        writeOpenSSHKeyString(writer, nbuf);\n\n        let comment = key.sshcomment || \"\";\n\n        if (options.type === \"der\") {\n            return writer.buf\n        } else {\n            return \"ssh-rsa \" + buf.toString(\"base64\") + \" \" + comment + \"\\n\";\n        }\n    },\n\n    publicImport: function (key, data, options) {\n        options = options || {};\n        var buffer;\n\n        if (options.type !== \"der\") {\n            if (Buffer.isBuffer(data)) {\n                data = data.toString(\"utf8\");\n            }\n\n            if (_.isString(data)) {\n                if (data.substring(0, 8) !== \"ssh-rsa \")\n                    throw Error(\"Unsupported key format\");\n                let pemEnd = data.indexOf(\" \", 8);\n\n                //Handle keys with no comment\n                if (pemEnd === -1) {\n                    pemEnd = data.length;\n                } else {\n                    key.sshcomment = data.substring(pemEnd + 1)\n                        .replace(/\\s+|\\n\\r|\\n|\\r$/gm, \"\");\n                }\n\n                const pem = data.substring(8, pemEnd)\n                    .replace(/\\s+|\\n\\r|\\n|\\r$/gm, \"\");\n                buffer = Buffer.from(pem, \"base64\");\n            } else {\n                throw Error(\"Unsupported key format\");\n            }\n        } else if (Buffer.isBuffer(data)) {\n            buffer = data;\n        } else {\n            throw Error(\"Unsupported key format\");\n        }\n\n        const reader = {buf: buffer, off: 0};\n\n        const type = readOpenSSHKeyString(reader).toString(\"ascii\");\n\n        if (type !== \"ssh-rsa\")\n            throw Error(\"Invalid key type: \" + type);\n\n        const e = readOpenSSHKeyString(reader);\n        const n = readOpenSSHKeyString(reader);\n\n        key.setPublic(\n            n,\n            e\n        );\n    },\n\n    /**\n     * Trying autodetect and import key\n     * @param key\n     * @param data\n     */\n    autoImport: function (key, data) {\n        // [\\S\\s]* matches zero or more of any character\n        if (/^[\\S\\s]*-----BEGIN OPENSSH PRIVATE KEY-----\\s*(?=(([A-Za-z0-9+/=]+\\s*)+))\\1-----END OPENSSH PRIVATE KEY-----[\\S\\s]*$/g.test(data)) {\n            module.exports.privateImport(key, data);\n            return true;\n        }\n\n        if (/^[\\S\\s]*ssh-rsa \\s*(?=(([A-Za-z0-9+/=]+\\s*)+))\\1[\\S\\s]*$/g.test(data)) {\n            module.exports.publicImport(key, data);\n            return true;\n        }\n\n        return false;\n    }\n};\n\nfunction readOpenSSHKeyString(reader) {\n    const len = reader.buf.readInt32BE(reader.off);\n    reader.off += 4;\n    const res = reader.buf.slice(reader.off, reader.off + len);\n    reader.off += len;\n    return res;\n}\n\nfunction writeOpenSSHKeyString(writer, data) {\n    writer.buf.writeInt32BE(data.byteLength, writer.off);\n    writer.off += 4;\n    writer.off += data.copy(writer.buf, writer.off);\n}"]},"metadata":{},"sourceType":"script"}