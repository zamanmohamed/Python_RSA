{"ast":null,"code":"var ber = require('asn1').Ber;\n\nvar _ = require('../utils')._;\n\nvar utils = require('../utils');\n\nconst PRIVATE_OPENING_BOUNDARY = '-----BEGIN RSA PRIVATE KEY-----';\nconst PRIVATE_CLOSING_BOUNDARY = '-----END RSA PRIVATE KEY-----';\nconst PUBLIC_OPENING_BOUNDARY = '-----BEGIN RSA PUBLIC KEY-----';\nconst PUBLIC_CLOSING_BOUNDARY = '-----END RSA PUBLIC KEY-----';\nmodule.exports = {\n  privateExport: function (key, options) {\n    options = options || {};\n    var n = key.n.toBuffer();\n    var d = key.d.toBuffer();\n    var p = key.p.toBuffer();\n    var q = key.q.toBuffer();\n    var dmp1 = key.dmp1.toBuffer();\n    var dmq1 = key.dmq1.toBuffer();\n    var coeff = key.coeff.toBuffer();\n    var length = n.length + d.length + p.length + q.length + dmp1.length + dmq1.length + coeff.length + 512; // magic\n\n    var writer = new ber.Writer({\n      size: length\n    });\n    writer.startSequence();\n    writer.writeInt(0);\n    writer.writeBuffer(n, 2);\n    writer.writeInt(key.e);\n    writer.writeBuffer(d, 2);\n    writer.writeBuffer(p, 2);\n    writer.writeBuffer(q, 2);\n    writer.writeBuffer(dmp1, 2);\n    writer.writeBuffer(dmq1, 2);\n    writer.writeBuffer(coeff, 2);\n    writer.endSequence();\n\n    if (options.type === 'der') {\n      return writer.buffer;\n    } else {\n      return PRIVATE_OPENING_BOUNDARY + '\\n' + utils.linebrk(writer.buffer.toString('base64'), 64) + '\\n' + PRIVATE_CLOSING_BOUNDARY;\n    }\n  },\n  privateImport: function (key, data, options) {\n    options = options || {};\n    var buffer;\n\n    if (options.type !== 'der') {\n      if (Buffer.isBuffer(data)) {\n        data = data.toString('utf8');\n      }\n\n      if (_.isString(data)) {\n        var pem = utils.trimSurroundingText(data, PRIVATE_OPENING_BOUNDARY, PRIVATE_CLOSING_BOUNDARY).replace(/\\s+|\\n\\r|\\n|\\r$/gm, '');\n        buffer = Buffer.from(pem, 'base64');\n      } else {\n        throw Error('Unsupported key format');\n      }\n    } else if (Buffer.isBuffer(data)) {\n      buffer = data;\n    } else {\n      throw Error('Unsupported key format');\n    }\n\n    var reader = new ber.Reader(buffer);\n    reader.readSequence();\n    reader.readString(2, true); // just zero\n\n    key.setPrivate(reader.readString(2, true), // modulus\n    reader.readString(2, true), // publicExponent\n    reader.readString(2, true), // privateExponent\n    reader.readString(2, true), // prime1\n    reader.readString(2, true), // prime2\n    reader.readString(2, true), // exponent1 -- d mod (p1)\n    reader.readString(2, true), // exponent2 -- d mod (q-1)\n    reader.readString(2, true) // coefficient -- (inverse of q) mod p\n    );\n  },\n  publicExport: function (key, options) {\n    options = options || {};\n    var n = key.n.toBuffer();\n    var length = n.length + 512; // magic\n\n    var bodyWriter = new ber.Writer({\n      size: length\n    });\n    bodyWriter.startSequence();\n    bodyWriter.writeBuffer(n, 2);\n    bodyWriter.writeInt(key.e);\n    bodyWriter.endSequence();\n\n    if (options.type === 'der') {\n      return bodyWriter.buffer;\n    } else {\n      return PUBLIC_OPENING_BOUNDARY + '\\n' + utils.linebrk(bodyWriter.buffer.toString('base64'), 64) + '\\n' + PUBLIC_CLOSING_BOUNDARY;\n    }\n  },\n  publicImport: function (key, data, options) {\n    options = options || {};\n    var buffer;\n\n    if (options.type !== 'der') {\n      if (Buffer.isBuffer(data)) {\n        data = data.toString('utf8');\n      }\n\n      if (_.isString(data)) {\n        var pem = utils.trimSurroundingText(data, PUBLIC_OPENING_BOUNDARY, PUBLIC_CLOSING_BOUNDARY).replace(/\\s+|\\n\\r|\\n|\\r$/gm, '');\n        buffer = Buffer.from(pem, 'base64');\n      }\n    } else if (Buffer.isBuffer(data)) {\n      buffer = data;\n    } else {\n      throw Error('Unsupported key format');\n    }\n\n    var body = new ber.Reader(buffer);\n    body.readSequence();\n    key.setPublic(body.readString(0x02, true), // modulus\n    body.readString(0x02, true) // publicExponent\n    );\n  },\n\n  /**\n   * Trying autodetect and import key\n   * @param key\n   * @param data\n   */\n  autoImport: function (key, data) {\n    // [\\S\\s]* matches zero or more of any character\n    if (/^[\\S\\s]*-----BEGIN RSA PRIVATE KEY-----\\s*(?=(([A-Za-z0-9+/=]+\\s*)+))\\1-----END RSA PRIVATE KEY-----[\\S\\s]*$/g.test(data)) {\n      module.exports.privateImport(key, data);\n      return true;\n    }\n\n    if (/^[\\S\\s]*-----BEGIN RSA PUBLIC KEY-----\\s*(?=(([A-Za-z0-9+/=]+\\s*)+))\\1-----END RSA PUBLIC KEY-----[\\S\\s]*$/g.test(data)) {\n      module.exports.publicImport(key, data);\n      return true;\n    }\n\n    return false;\n  }\n};","map":{"version":3,"sources":["C:/Users/Zaman/zaman/RSA/front/node_modules/node-rsa/src/formats/pkcs1.js"],"names":["ber","require","Ber","_","utils","PRIVATE_OPENING_BOUNDARY","PRIVATE_CLOSING_BOUNDARY","PUBLIC_OPENING_BOUNDARY","PUBLIC_CLOSING_BOUNDARY","module","exports","privateExport","key","options","n","toBuffer","d","p","q","dmp1","dmq1","coeff","length","writer","Writer","size","startSequence","writeInt","writeBuffer","e","endSequence","type","buffer","linebrk","toString","privateImport","data","Buffer","isBuffer","isString","pem","trimSurroundingText","replace","from","Error","reader","Reader","readSequence","readString","setPrivate","publicExport","bodyWriter","publicImport","body","setPublic","autoImport","test"],"mappings":"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","sourcesContent":["var ber = require('asn1').Ber;\nvar _ = require('../utils')._;\nvar utils = require('../utils');\n\nconst PRIVATE_OPENING_BOUNDARY = '-----BEGIN RSA PRIVATE KEY-----';\nconst PRIVATE_CLOSING_BOUNDARY = '-----END RSA PRIVATE KEY-----';\n\nconst PUBLIC_OPENING_BOUNDARY = '-----BEGIN RSA PUBLIC KEY-----';\nconst PUBLIC_CLOSING_BOUNDARY = '-----END RSA PUBLIC KEY-----';\n\nmodule.exports = {\n    privateExport: function (key, options) {\n        options = options || {};\n\n        var n = key.n.toBuffer();\n        var d = key.d.toBuffer();\n        var p = key.p.toBuffer();\n        var q = key.q.toBuffer();\n        var dmp1 = key.dmp1.toBuffer();\n        var dmq1 = key.dmq1.toBuffer();\n        var coeff = key.coeff.toBuffer();\n\n        var length = n.length + d.length + p.length + q.length + dmp1.length + dmq1.length + coeff.length + 512; // magic\n        var writer = new ber.Writer({size: length});\n\n        writer.startSequence();\n        writer.writeInt(0);\n        writer.writeBuffer(n, 2);\n        writer.writeInt(key.e);\n        writer.writeBuffer(d, 2);\n        writer.writeBuffer(p, 2);\n        writer.writeBuffer(q, 2);\n        writer.writeBuffer(dmp1, 2);\n        writer.writeBuffer(dmq1, 2);\n        writer.writeBuffer(coeff, 2);\n        writer.endSequence();\n\n        if (options.type === 'der') {\n            return writer.buffer;\n        } else {\n            return PRIVATE_OPENING_BOUNDARY + '\\n' + utils.linebrk(writer.buffer.toString('base64'), 64) + '\\n' + PRIVATE_CLOSING_BOUNDARY;\n        }\n    },\n\n    privateImport: function (key, data, options) {\n        options = options || {};\n        var buffer;\n\n        if (options.type !== 'der') {\n            if (Buffer.isBuffer(data)) {\n                data = data.toString('utf8');\n            }\n\n            if (_.isString(data)) {\n                var pem = utils.trimSurroundingText(data, PRIVATE_OPENING_BOUNDARY, PRIVATE_CLOSING_BOUNDARY)\n                    .replace(/\\s+|\\n\\r|\\n|\\r$/gm, '');\n                buffer = Buffer.from(pem, 'base64');\n            } else {\n                throw Error('Unsupported key format');\n            }\n        } else if (Buffer.isBuffer(data)) {\n            buffer = data;\n        } else {\n            throw Error('Unsupported key format');\n        }\n\n        var reader = new ber.Reader(buffer);\n        reader.readSequence();\n        reader.readString(2, true); // just zero\n        key.setPrivate(\n            reader.readString(2, true),  // modulus\n            reader.readString(2, true),  // publicExponent\n            reader.readString(2, true),  // privateExponent\n            reader.readString(2, true),  // prime1\n            reader.readString(2, true),  // prime2\n            reader.readString(2, true),  // exponent1 -- d mod (p1)\n            reader.readString(2, true),  // exponent2 -- d mod (q-1)\n            reader.readString(2, true)   // coefficient -- (inverse of q) mod p\n        );\n    },\n\n    publicExport: function (key, options) {\n        options = options || {};\n\n        var n = key.n.toBuffer();\n        var length = n.length + 512; // magic\n\n        var bodyWriter = new ber.Writer({size: length});\n        bodyWriter.startSequence();\n        bodyWriter.writeBuffer(n, 2);\n        bodyWriter.writeInt(key.e);\n        bodyWriter.endSequence();\n\n        if (options.type === 'der') {\n            return bodyWriter.buffer;\n        } else {\n            return PUBLIC_OPENING_BOUNDARY + '\\n' + utils.linebrk(bodyWriter.buffer.toString('base64'), 64) + '\\n' + PUBLIC_CLOSING_BOUNDARY;\n        }\n    },\n\n    publicImport: function (key, data, options) {\n        options = options || {};\n        var buffer;\n\n        if (options.type !== 'der') {\n            if (Buffer.isBuffer(data)) {\n                data = data.toString('utf8');\n            }\n\n            if (_.isString(data)) {\n                var pem = utils.trimSurroundingText(data, PUBLIC_OPENING_BOUNDARY, PUBLIC_CLOSING_BOUNDARY)\n                    .replace(/\\s+|\\n\\r|\\n|\\r$/gm, '');\n                buffer = Buffer.from(pem, 'base64');\n            }\n        } else if (Buffer.isBuffer(data)) {\n            buffer = data;\n        } else {\n            throw Error('Unsupported key format');\n        }\n\n        var body = new ber.Reader(buffer);\n        body.readSequence();\n        key.setPublic(\n            body.readString(0x02, true), // modulus\n            body.readString(0x02, true)  // publicExponent\n        );\n    },\n\n    /**\n     * Trying autodetect and import key\n     * @param key\n     * @param data\n     */\n    autoImport: function (key, data) {\n        // [\\S\\s]* matches zero or more of any character\n        if (/^[\\S\\s]*-----BEGIN RSA PRIVATE KEY-----\\s*(?=(([A-Za-z0-9+/=]+\\s*)+))\\1-----END RSA PRIVATE KEY-----[\\S\\s]*$/g.test(data)) {\n            module.exports.privateImport(key, data);\n            return true;\n        }\n\n        if (/^[\\S\\s]*-----BEGIN RSA PUBLIC KEY-----\\s*(?=(([A-Za-z0-9+/=]+\\s*)+))\\1-----END RSA PUBLIC KEY-----[\\S\\s]*$/g.test(data)) {\n            module.exports.publicImport(key, data);\n            return true;\n        }\n\n        return false;\n    }\n};"]},"metadata":{},"sourceType":"script"}