{"ast":null,"code":"/**\n * PKCS1 padding and signature scheme\n */\nvar BigInteger = require('../libs/jsbn');\n\nvar crypt = require('crypto');\n\nvar constants = require('constants');\n\nvar SIGN_INFO_HEAD = {\n  md2: Buffer.from('3020300c06082a864886f70d020205000410', 'hex'),\n  md5: Buffer.from('3020300c06082a864886f70d020505000410', 'hex'),\n  sha1: Buffer.from('3021300906052b0e03021a05000414', 'hex'),\n  sha224: Buffer.from('302d300d06096086480165030402040500041c', 'hex'),\n  sha256: Buffer.from('3031300d060960864801650304020105000420', 'hex'),\n  sha384: Buffer.from('3041300d060960864801650304020205000430', 'hex'),\n  sha512: Buffer.from('3051300d060960864801650304020305000440', 'hex'),\n  ripemd160: Buffer.from('3021300906052b2403020105000414', 'hex'),\n  rmd160: Buffer.from('3021300906052b2403020105000414', 'hex')\n};\nvar SIGN_ALG_TO_HASH_ALIASES = {\n  'ripemd160': 'rmd160'\n};\nvar DEFAULT_HASH_FUNCTION = 'sha256';\nmodule.exports = {\n  isEncryption: true,\n  isSignature: true\n};\n\nmodule.exports.makeScheme = function (key, options) {\n  function Scheme(key, options) {\n    this.key = key;\n    this.options = options;\n  }\n\n  Scheme.prototype.maxMessageLength = function () {\n    if (this.options.encryptionSchemeOptions && this.options.encryptionSchemeOptions.padding == constants.RSA_NO_PADDING) {\n      return this.key.encryptedDataLength;\n    }\n\n    return this.key.encryptedDataLength - 11;\n  };\n  /**\n   * Pad input Buffer to encryptedDataLength bytes, and return Buffer.from\n   * alg: PKCS#1\n   * @param buffer\n   * @returns {Buffer}\n   */\n\n\n  Scheme.prototype.encPad = function (buffer, options) {\n    options = options || {};\n    var filled;\n\n    if (buffer.length > this.key.maxMessageLength) {\n      throw new Error(\"Message too long for RSA (n=\" + this.key.encryptedDataLength + \", l=\" + buffer.length + \")\");\n    }\n\n    if (this.options.encryptionSchemeOptions && this.options.encryptionSchemeOptions.padding == constants.RSA_NO_PADDING) {\n      //RSA_NO_PADDING treated like JAVA left pad with zero character\n      filled = Buffer.alloc(this.key.maxMessageLength - buffer.length);\n      filled.fill(0);\n      return Buffer.concat([filled, buffer]);\n    }\n    /* Type 1: zeros padding for private key encrypt */\n\n\n    if (options.type === 1) {\n      filled = Buffer.alloc(this.key.encryptedDataLength - buffer.length - 1);\n      filled.fill(0xff, 0, filled.length - 1);\n      filled[0] = 1;\n      filled[filled.length - 1] = 0;\n      return Buffer.concat([filled, buffer]);\n    } else {\n      /* random padding for public key encrypt */\n      filled = Buffer.alloc(this.key.encryptedDataLength - buffer.length);\n      filled[0] = 0;\n      filled[1] = 2;\n      var rand = crypt.randomBytes(filled.length - 3);\n\n      for (var i = 0; i < rand.length; i++) {\n        var r = rand[i];\n\n        while (r === 0) {\n          // non-zero only\n          r = crypt.randomBytes(1)[0];\n        }\n\n        filled[i + 2] = r;\n      }\n\n      filled[filled.length - 1] = 0;\n      return Buffer.concat([filled, buffer]);\n    }\n  };\n  /**\n   * Unpad input Buffer and, if valid, return the Buffer object\n   * alg: PKCS#1 (type 2, random)\n   * @param buffer\n   * @returns {Buffer}\n   */\n\n\n  Scheme.prototype.encUnPad = function (buffer, options) {\n    options = options || {};\n    var i = 0;\n\n    if (this.options.encryptionSchemeOptions && this.options.encryptionSchemeOptions.padding == constants.RSA_NO_PADDING) {\n      //RSA_NO_PADDING treated like JAVA left pad with zero character\n      var unPad;\n\n      if (typeof buffer.lastIndexOf == \"function\") {\n        //patch for old node version\n        unPad = buffer.slice(buffer.lastIndexOf('\\0') + 1, buffer.length);\n      } else {\n        unPad = buffer.slice(String.prototype.lastIndexOf.call(buffer, '\\0') + 1, buffer.length);\n      }\n\n      return unPad;\n    }\n\n    if (buffer.length < 4) {\n      return null;\n    }\n    /* Type 1: zeros padding for private key decrypt */\n\n\n    if (options.type === 1) {\n      if (buffer[0] !== 0 || buffer[1] !== 1) {\n        return null;\n      }\n\n      i = 3;\n\n      while (buffer[i] !== 0) {\n        if (buffer[i] != 0xFF || ++i >= buffer.length) {\n          return null;\n        }\n      }\n    } else {\n      /* random padding for public key decrypt */\n      if (buffer[0] !== 0 || buffer[1] !== 2) {\n        return null;\n      }\n\n      i = 3;\n\n      while (buffer[i] !== 0) {\n        if (++i >= buffer.length) {\n          return null;\n        }\n      }\n    }\n\n    return buffer.slice(i + 1, buffer.length);\n  };\n\n  Scheme.prototype.sign = function (buffer) {\n    var hashAlgorithm = this.options.signingSchemeOptions.hash || DEFAULT_HASH_FUNCTION;\n\n    if (this.options.environment === 'browser') {\n      hashAlgorithm = SIGN_ALG_TO_HASH_ALIASES[hashAlgorithm] || hashAlgorithm;\n      var hasher = crypt.createHash(hashAlgorithm);\n      hasher.update(buffer);\n      var hash = this.pkcs1pad(hasher.digest(), hashAlgorithm);\n      var res = this.key.$doPrivate(new BigInteger(hash)).toBuffer(this.key.encryptedDataLength);\n      return res;\n    } else {\n      var signer = crypt.createSign('RSA-' + hashAlgorithm.toUpperCase());\n      signer.update(buffer);\n      return signer.sign(this.options.rsaUtils.exportKey('private'));\n    }\n  };\n\n  Scheme.prototype.verify = function (buffer, signature, signature_encoding) {\n    if (this.options.encryptionSchemeOptions && this.options.encryptionSchemeOptions.padding == constants.RSA_NO_PADDING) {\n      //RSA_NO_PADDING has no verify data\n      return false;\n    }\n\n    var hashAlgorithm = this.options.signingSchemeOptions.hash || DEFAULT_HASH_FUNCTION;\n\n    if (this.options.environment === 'browser') {\n      hashAlgorithm = SIGN_ALG_TO_HASH_ALIASES[hashAlgorithm] || hashAlgorithm;\n\n      if (signature_encoding) {\n        signature = Buffer.from(signature, signature_encoding);\n      }\n\n      var hasher = crypt.createHash(hashAlgorithm);\n      hasher.update(buffer);\n      var hash = this.pkcs1pad(hasher.digest(), hashAlgorithm);\n      var m = this.key.$doPublic(new BigInteger(signature));\n      return m.toBuffer().toString('hex') == hash.toString('hex');\n    } else {\n      var verifier = crypt.createVerify('RSA-' + hashAlgorithm.toUpperCase());\n      verifier.update(buffer);\n      return verifier.verify(this.options.rsaUtils.exportKey('public'), signature, signature_encoding);\n    }\n  };\n  /**\n   * PKCS#1 zero pad input buffer to max data length\n   * @param hashBuf\n   * @param hashAlgorithm\n   * @returns {*}\n   */\n\n\n  Scheme.prototype.pkcs0pad = function (buffer) {\n    var filled = Buffer.alloc(this.key.maxMessageLength - buffer.length);\n    filled.fill(0);\n    return Buffer.concat([filled, buffer]);\n  };\n\n  Scheme.prototype.pkcs0unpad = function (buffer) {\n    var unPad;\n\n    if (typeof buffer.lastIndexOf == \"function\") {\n      //patch for old node version\n      unPad = buffer.slice(buffer.lastIndexOf('\\0') + 1, buffer.length);\n    } else {\n      unPad = buffer.slice(String.prototype.lastIndexOf.call(buffer, '\\0') + 1, buffer.length);\n    }\n\n    return unPad;\n  };\n  /**\n   * PKCS#1 pad input buffer to max data length\n   * @param hashBuf\n   * @param hashAlgorithm\n   * @returns {*}\n   */\n\n\n  Scheme.prototype.pkcs1pad = function (hashBuf, hashAlgorithm) {\n    var digest = SIGN_INFO_HEAD[hashAlgorithm];\n\n    if (!digest) {\n      throw Error('Unsupported hash algorithm');\n    }\n\n    var data = Buffer.concat([digest, hashBuf]);\n\n    if (data.length + 10 > this.key.encryptedDataLength) {\n      throw Error('Key is too short for signing algorithm (' + hashAlgorithm + ')');\n    }\n\n    var filled = Buffer.alloc(this.key.encryptedDataLength - data.length - 1);\n    filled.fill(0xff, 0, filled.length - 1);\n    filled[0] = 1;\n    filled[filled.length - 1] = 0;\n    var res = Buffer.concat([filled, data]);\n    return res;\n  };\n\n  return new Scheme(key, options);\n};","map":{"version":3,"sources":["C:/Users/Zaman/zaman/RSA/front/node_modules/node-rsa/src/schemes/pkcs1.js"],"names":["BigInteger","require","crypt","constants","SIGN_INFO_HEAD","md2","Buffer","from","md5","sha1","sha224","sha256","sha384","sha512","ripemd160","rmd160","SIGN_ALG_TO_HASH_ALIASES","DEFAULT_HASH_FUNCTION","module","exports","isEncryption","isSignature","makeScheme","key","options","Scheme","prototype","maxMessageLength","encryptionSchemeOptions","padding","RSA_NO_PADDING","encryptedDataLength","encPad","buffer","filled","length","Error","alloc","fill","concat","type","rand","randomBytes","i","r","encUnPad","unPad","lastIndexOf","slice","String","call","sign","hashAlgorithm","signingSchemeOptions","hash","environment","hasher","createHash","update","pkcs1pad","digest","res","$doPrivate","toBuffer","signer","createSign","toUpperCase","rsaUtils","exportKey","verify","signature","signature_encoding","m","$doPublic","toString","verifier","createVerify","pkcs0pad","pkcs0unpad","hashBuf","data"],"mappings":"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","sourcesContent":["/**\n * PKCS1 padding and signature scheme\n */\n\nvar BigInteger = require('../libs/jsbn');\nvar crypt = require('crypto');\nvar constants = require('constants');\nvar SIGN_INFO_HEAD = {\n    md2: Buffer.from('3020300c06082a864886f70d020205000410', 'hex'),\n    md5: Buffer.from('3020300c06082a864886f70d020505000410', 'hex'),\n    sha1: Buffer.from('3021300906052b0e03021a05000414', 'hex'),\n    sha224: Buffer.from('302d300d06096086480165030402040500041c', 'hex'),\n    sha256: Buffer.from('3031300d060960864801650304020105000420', 'hex'),\n    sha384: Buffer.from('3041300d060960864801650304020205000430', 'hex'),\n    sha512: Buffer.from('3051300d060960864801650304020305000440', 'hex'),\n    ripemd160: Buffer.from('3021300906052b2403020105000414', 'hex'),\n    rmd160: Buffer.from('3021300906052b2403020105000414', 'hex')\n};\n\nvar SIGN_ALG_TO_HASH_ALIASES = {\n    'ripemd160': 'rmd160'\n};\n\nvar DEFAULT_HASH_FUNCTION = 'sha256';\n\nmodule.exports = {\n    isEncryption: true,\n    isSignature: true\n};\n\nmodule.exports.makeScheme = function (key, options) {\n    function Scheme(key, options) {\n        this.key = key;\n        this.options = options;\n    }\n\n    Scheme.prototype.maxMessageLength = function () {\n        if (this.options.encryptionSchemeOptions && this.options.encryptionSchemeOptions.padding == constants.RSA_NO_PADDING) {\n            return this.key.encryptedDataLength;\n        }\n        return this.key.encryptedDataLength - 11;\n    };\n\n    /**\n     * Pad input Buffer to encryptedDataLength bytes, and return Buffer.from\n     * alg: PKCS#1\n     * @param buffer\n     * @returns {Buffer}\n     */\n    Scheme.prototype.encPad = function (buffer, options) {\n        options = options || {};\n        var filled;\n        if (buffer.length > this.key.maxMessageLength) {\n            throw new Error(\"Message too long for RSA (n=\" + this.key.encryptedDataLength + \", l=\" + buffer.length + \")\");\n        }\n        if (this.options.encryptionSchemeOptions && this.options.encryptionSchemeOptions.padding == constants.RSA_NO_PADDING) {\n            //RSA_NO_PADDING treated like JAVA left pad with zero character\n            filled = Buffer.alloc(this.key.maxMessageLength - buffer.length);\n            filled.fill(0);\n            return Buffer.concat([filled, buffer]);\n        }\n\n        /* Type 1: zeros padding for private key encrypt */\n        if (options.type === 1) {\n            filled = Buffer.alloc(this.key.encryptedDataLength - buffer.length - 1);\n            filled.fill(0xff, 0, filled.length - 1);\n            filled[0] = 1;\n            filled[filled.length - 1] = 0;\n\n            return Buffer.concat([filled, buffer]);\n        } else {\n            /* random padding for public key encrypt */\n            filled = Buffer.alloc(this.key.encryptedDataLength - buffer.length);\n            filled[0] = 0;\n            filled[1] = 2;\n            var rand = crypt.randomBytes(filled.length - 3);\n            for (var i = 0; i < rand.length; i++) {\n                var r = rand[i];\n                while (r === 0) { // non-zero only\n                    r = crypt.randomBytes(1)[0];\n                }\n                filled[i + 2] = r;\n            }\n            filled[filled.length - 1] = 0;\n            return Buffer.concat([filled, buffer]);\n        }\n    };\n\n    /**\n     * Unpad input Buffer and, if valid, return the Buffer object\n     * alg: PKCS#1 (type 2, random)\n     * @param buffer\n     * @returns {Buffer}\n     */\n    Scheme.prototype.encUnPad = function (buffer, options) {\n        options = options || {};\n        var i = 0;\n\n        if (this.options.encryptionSchemeOptions && this.options.encryptionSchemeOptions.padding == constants.RSA_NO_PADDING) {\n            //RSA_NO_PADDING treated like JAVA left pad with zero character\n            var unPad;\n            if (typeof buffer.lastIndexOf == \"function\") { //patch for old node version\n                unPad = buffer.slice(buffer.lastIndexOf('\\0') + 1, buffer.length);\n            } else {\n                unPad = buffer.slice(String.prototype.lastIndexOf.call(buffer, '\\0') + 1, buffer.length);\n            }\n            return unPad;\n        }\n\n        if (buffer.length < 4) {\n            return null;\n        }\n\n        /* Type 1: zeros padding for private key decrypt */\n        if (options.type === 1) {\n            if (buffer[0] !== 0 || buffer[1] !== 1) {\n                return null;\n            }\n            i = 3;\n            while (buffer[i] !== 0) {\n                if (buffer[i] != 0xFF || ++i >= buffer.length) {\n                    return null;\n                }\n            }\n        } else {\n            /* random padding for public key decrypt */\n            if (buffer[0] !== 0 || buffer[1] !== 2) {\n                return null;\n            }\n            i = 3;\n            while (buffer[i] !== 0) {\n                if (++i >= buffer.length) {\n                    return null;\n                }\n            }\n        }\n        return buffer.slice(i + 1, buffer.length);\n    };\n\n    Scheme.prototype.sign = function (buffer) {\n        var hashAlgorithm = this.options.signingSchemeOptions.hash || DEFAULT_HASH_FUNCTION;\n        if (this.options.environment === 'browser') {\n            hashAlgorithm = SIGN_ALG_TO_HASH_ALIASES[hashAlgorithm] || hashAlgorithm;\n\n            var hasher = crypt.createHash(hashAlgorithm);\n            hasher.update(buffer);\n            var hash = this.pkcs1pad(hasher.digest(), hashAlgorithm);\n            var res = this.key.$doPrivate(new BigInteger(hash)).toBuffer(this.key.encryptedDataLength);\n\n            return res;\n        } else {\n            var signer = crypt.createSign('RSA-' + hashAlgorithm.toUpperCase());\n            signer.update(buffer);\n            return signer.sign(this.options.rsaUtils.exportKey('private'));\n        }\n    };\n\n    Scheme.prototype.verify = function (buffer, signature, signature_encoding) {\n        if (this.options.encryptionSchemeOptions && this.options.encryptionSchemeOptions.padding == constants.RSA_NO_PADDING) {\n            //RSA_NO_PADDING has no verify data\n            return false;\n        }\n        var hashAlgorithm = this.options.signingSchemeOptions.hash || DEFAULT_HASH_FUNCTION;\n        if (this.options.environment === 'browser') {\n            hashAlgorithm = SIGN_ALG_TO_HASH_ALIASES[hashAlgorithm] || hashAlgorithm;\n\n            if (signature_encoding) {\n                signature = Buffer.from(signature, signature_encoding);\n            }\n\n            var hasher = crypt.createHash(hashAlgorithm);\n            hasher.update(buffer);\n            var hash = this.pkcs1pad(hasher.digest(), hashAlgorithm);\n            var m = this.key.$doPublic(new BigInteger(signature));\n\n            return m.toBuffer().toString('hex') == hash.toString('hex');\n        } else {\n            var verifier = crypt.createVerify('RSA-' + hashAlgorithm.toUpperCase());\n            verifier.update(buffer);\n            return verifier.verify(this.options.rsaUtils.exportKey('public'), signature, signature_encoding);\n        }\n    };\n\n    /**\n     * PKCS#1 zero pad input buffer to max data length\n     * @param hashBuf\n     * @param hashAlgorithm\n     * @returns {*}\n     */\n    Scheme.prototype.pkcs0pad = function (buffer) {\n        var filled = Buffer.alloc(this.key.maxMessageLength - buffer.length);\n        filled.fill(0);\n        return Buffer.concat([filled, buffer]);\n    };\n\n    Scheme.prototype.pkcs0unpad = function (buffer) {\n        var unPad;\n        if (typeof buffer.lastIndexOf == \"function\") { //patch for old node version\n            unPad = buffer.slice(buffer.lastIndexOf('\\0') + 1, buffer.length);\n        } else {\n            unPad = buffer.slice(String.prototype.lastIndexOf.call(buffer, '\\0') + 1, buffer.length);\n        }\n\n        return unPad;\n    };\n\n    /**\n     * PKCS#1 pad input buffer to max data length\n     * @param hashBuf\n     * @param hashAlgorithm\n     * @returns {*}\n     */\n    Scheme.prototype.pkcs1pad = function (hashBuf, hashAlgorithm) {\n        var digest = SIGN_INFO_HEAD[hashAlgorithm];\n        if (!digest) {\n            throw Error('Unsupported hash algorithm');\n        }\n\n        var data = Buffer.concat([digest, hashBuf]);\n\n        if (data.length + 10 > this.key.encryptedDataLength) {\n            throw Error('Key is too short for signing algorithm (' + hashAlgorithm + ')');\n        }\n\n        var filled = Buffer.alloc(this.key.encryptedDataLength - data.length - 1);\n        filled.fill(0xff, 0, filled.length - 1);\n        filled[0] = 1;\n        filled[filled.length - 1] = 0;\n\n        var res = Buffer.concat([filled, data]);\n\n        return res;\n    };\n\n    return new Scheme(key, options);\n};\n\n\n"]},"metadata":{},"sourceType":"script"}