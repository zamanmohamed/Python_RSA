{"ast":null,"code":"/*\n * Utils functions\n *\n */\nvar crypt = require('crypto');\n/**\n * Break string str each maxLen symbols\n * @param str\n * @param maxLen\n * @returns {string}\n */\n\n\nmodule.exports.linebrk = function (str, maxLen) {\n  var res = '';\n  var i = 0;\n\n  while (i + maxLen < str.length) {\n    res += str.substring(i, i + maxLen) + \"\\n\";\n    i += maxLen;\n  }\n\n  return res + str.substring(i, str.length);\n};\n\nmodule.exports.detectEnvironment = function () {\n  if (typeof window !== 'undefined' && window && !(process && process.title === 'node')) {\n    return 'browser';\n  }\n\n  return 'node';\n};\n/**\n * Trying get a 32-bit unsigned integer from the partial buffer\n * @param buffer\n * @param offset\n * @returns {Number}\n */\n\n\nmodule.exports.get32IntFromBuffer = function (buffer, offset) {\n  offset = offset || 0;\n  var size = 0;\n\n  if ((size = buffer.length - offset) > 0) {\n    if (size >= 4) {\n      return buffer.readUIntBE(offset, size);\n    } else {\n      var res = 0;\n\n      for (var i = offset + size, d = 0; i > offset; i--, d += 2) {\n        res += buffer[i - 1] * Math.pow(16, d);\n      }\n\n      return res;\n    }\n  } else {\n    return NaN;\n  }\n};\n\nmodule.exports._ = {\n  isObject: function (value) {\n    var type = typeof value;\n    return !!value && (type == 'object' || type == 'function');\n  },\n  isString: function (value) {\n    return typeof value == 'string' || value instanceof String;\n  },\n  isNumber: function (value) {\n    return typeof value == 'number' || !isNaN(parseFloat(value)) && isFinite(value);\n  },\n\n  /**\n   * Returns copy of `obj` without `removeProp` field.\n   * @param obj\n   * @param removeProp\n   * @returns Object\n   */\n  omit: function (obj, removeProp) {\n    var newObj = {};\n\n    for (var prop in obj) {\n      if (!obj.hasOwnProperty(prop) || prop === removeProp) {\n        continue;\n      }\n\n      newObj[prop] = obj[prop];\n    }\n\n    return newObj;\n  }\n};\n/**\n * Strips everything around the opening and closing lines, including the lines\n * themselves.\n */\n\nmodule.exports.trimSurroundingText = function (data, opening, closing) {\n  var trimStartIndex = 0;\n  var trimEndIndex = data.length;\n  var openingBoundaryIndex = data.indexOf(opening);\n\n  if (openingBoundaryIndex >= 0) {\n    trimStartIndex = openingBoundaryIndex + opening.length;\n  }\n\n  var closingBoundaryIndex = data.indexOf(closing, openingBoundaryIndex);\n\n  if (closingBoundaryIndex >= 0) {\n    trimEndIndex = closingBoundaryIndex;\n  }\n\n  return data.substring(trimStartIndex, trimEndIndex);\n};","map":{"version":3,"sources":["C:/Users/Zaman/zaman/RSA/front/node_modules/node-rsa/src/utils.js"],"names":["crypt","require","module","exports","linebrk","str","maxLen","res","i","length","substring","detectEnvironment","window","process","title","get32IntFromBuffer","buffer","offset","size","readUIntBE","d","Math","pow","NaN","_","isObject","value","type","isString","String","isNumber","isNaN","parseFloat","isFinite","omit","obj","removeProp","newObj","prop","hasOwnProperty","trimSurroundingText","data","opening","closing","trimStartIndex","trimEndIndex","openingBoundaryIndex","indexOf","closingBoundaryIndex"],"mappings":"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","sourcesContent":["/*\n * Utils functions\n *\n */\n\nvar crypt = require('crypto');\n\n/**\n * Break string str each maxLen symbols\n * @param str\n * @param maxLen\n * @returns {string}\n */\nmodule.exports.linebrk = function (str, maxLen) {\n    var res = '';\n    var i = 0;\n    while (i + maxLen < str.length) {\n        res += str.substring(i, i + maxLen) + \"\\n\";\n        i += maxLen;\n    }\n    return res + str.substring(i, str.length);\n};\n\nmodule.exports.detectEnvironment = function () {\n    if (typeof(window) !== 'undefined' && window && !(process && process.title === 'node')) {\n        return 'browser';\n    }\n\n    return 'node';\n};\n\n/**\n * Trying get a 32-bit unsigned integer from the partial buffer\n * @param buffer\n * @param offset\n * @returns {Number}\n */\nmodule.exports.get32IntFromBuffer = function (buffer, offset) {\n    offset = offset || 0;\n    var size = 0;\n    if ((size = buffer.length - offset) > 0) {\n        if (size >= 4) {\n            return buffer.readUIntBE(offset, size);\n        } else {\n            var res = 0;\n            for (var i = offset + size, d = 0; i > offset; i--, d += 2) {\n                res += buffer[i - 1] * Math.pow(16, d);\n            }\n            return res;\n        }\n    } else {\n        return NaN;\n    }\n};\n\nmodule.exports._ = {\n    isObject: function (value) {\n        var type = typeof value;\n        return !!value && (type == 'object' || type == 'function');\n    },\n\n    isString: function (value) {\n        return typeof value == 'string' || value instanceof String;\n    },\n\n    isNumber: function (value) {\n        return typeof value == 'number' || !isNaN(parseFloat(value)) && isFinite(value);\n    },\n\n    /**\n     * Returns copy of `obj` without `removeProp` field.\n     * @param obj\n     * @param removeProp\n     * @returns Object\n     */\n    omit: function (obj, removeProp) {\n        var newObj = {};\n        for (var prop in obj) {\n            if (!obj.hasOwnProperty(prop) || prop === removeProp) {\n                continue;\n            }\n            newObj[prop] = obj[prop];\n        }\n\n        return newObj;\n    }\n};\n\n/**\n * Strips everything around the opening and closing lines, including the lines\n * themselves.\n */\nmodule.exports.trimSurroundingText = function (data, opening, closing) {\n    var trimStartIndex = 0;\n    var trimEndIndex = data.length;\n\n    var openingBoundaryIndex = data.indexOf(opening);\n    if (openingBoundaryIndex >= 0) {\n        trimStartIndex = openingBoundaryIndex + opening.length;\n    }\n\n    var closingBoundaryIndex = data.indexOf(closing, openingBoundaryIndex);\n    if (closingBoundaryIndex >= 0) {\n        trimEndIndex = closingBoundaryIndex;\n    }\n\n    return data.substring(trimStartIndex, trimEndIndex);\n}"]},"metadata":{},"sourceType":"script"}