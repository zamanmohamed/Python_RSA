{"ast":null,"code":"/*!\n * RSA library for Node.js\n *\n * Author: rzcoder\n * License MIT\n */\nvar constants = require('constants');\n\nvar rsa = require('./libs/rsa.js');\n\nvar crypt = require('crypto');\n\nvar ber = require('asn1').Ber;\n\nvar _ = require('./utils')._;\n\nvar utils = require('./utils');\n\nvar schemes = require('./schemes/schemes.js');\n\nvar formats = require('./formats/formats.js');\n\nif (typeof constants.RSA_NO_PADDING === \"undefined\") {\n  //patch for node v0.10.x, constants do not defined\n  constants.RSA_NO_PADDING = 3;\n}\n\nmodule.exports = function () {\n  var SUPPORTED_HASH_ALGORITHMS = {\n    node10: ['md4', 'md5', 'ripemd160', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512'],\n    node: ['md4', 'md5', 'ripemd160', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512'],\n    iojs: ['md4', 'md5', 'ripemd160', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512'],\n    browser: ['md5', 'ripemd160', 'sha1', 'sha256', 'sha512']\n  };\n  var DEFAULT_ENCRYPTION_SCHEME = 'pkcs1_oaep';\n  var DEFAULT_SIGNING_SCHEME = 'pkcs1';\n  var DEFAULT_EXPORT_FORMAT = 'private';\n  var EXPORT_FORMAT_ALIASES = {\n    'private': 'pkcs1-private-pem',\n    'private-der': 'pkcs1-private-der',\n    'public': 'pkcs8-public-pem',\n    'public-der': 'pkcs8-public-der'\n  };\n  /**\n   * @param key {string|buffer|object} Key in PEM format, or data for generate key {b: bits, e: exponent}\n   * @constructor\n   */\n\n  function NodeRSA(key, format, options) {\n    if (!(this instanceof NodeRSA)) {\n      return new NodeRSA(key, format, options);\n    }\n\n    if (_.isObject(format)) {\n      options = format;\n      format = undefined;\n    }\n\n    this.$options = {\n      signingScheme: DEFAULT_SIGNING_SCHEME,\n      signingSchemeOptions: {\n        hash: 'sha256',\n        saltLength: null\n      },\n      encryptionScheme: DEFAULT_ENCRYPTION_SCHEME,\n      encryptionSchemeOptions: {\n        hash: 'sha1',\n        label: null\n      },\n      environment: utils.detectEnvironment(),\n      rsaUtils: this\n    };\n    this.keyPair = new rsa.Key();\n    this.$cache = {};\n\n    if (Buffer.isBuffer(key) || _.isString(key)) {\n      this.importKey(key, format);\n    } else if (_.isObject(key)) {\n      this.generateKeyPair(key.b, key.e);\n    }\n\n    this.setOptions(options);\n  }\n  /**\n   * Set and validate options for key instance\n   * @param options\n   */\n\n\n  NodeRSA.prototype.setOptions = function (options) {\n    options = options || {};\n\n    if (options.environment) {\n      this.$options.environment = options.environment;\n    }\n\n    if (options.signingScheme) {\n      if (_.isString(options.signingScheme)) {\n        var signingScheme = options.signingScheme.toLowerCase().split('-');\n\n        if (signingScheme.length == 1) {\n          if (SUPPORTED_HASH_ALGORITHMS.node.indexOf(signingScheme[0]) > -1) {\n            this.$options.signingSchemeOptions = {\n              hash: signingScheme[0]\n            };\n            this.$options.signingScheme = DEFAULT_SIGNING_SCHEME;\n          } else {\n            this.$options.signingScheme = signingScheme[0];\n            this.$options.signingSchemeOptions = {\n              hash: null\n            };\n          }\n        } else {\n          this.$options.signingSchemeOptions = {\n            hash: signingScheme[1]\n          };\n          this.$options.signingScheme = signingScheme[0];\n        }\n      } else if (_.isObject(options.signingScheme)) {\n        this.$options.signingScheme = options.signingScheme.scheme || DEFAULT_SIGNING_SCHEME;\n        this.$options.signingSchemeOptions = _.omit(options.signingScheme, 'scheme');\n      }\n\n      if (!schemes.isSignature(this.$options.signingScheme)) {\n        throw Error('Unsupported signing scheme');\n      }\n\n      if (this.$options.signingSchemeOptions.hash && SUPPORTED_HASH_ALGORITHMS[this.$options.environment].indexOf(this.$options.signingSchemeOptions.hash) === -1) {\n        throw Error('Unsupported hashing algorithm for ' + this.$options.environment + ' environment');\n      }\n    }\n\n    if (options.encryptionScheme) {\n      if (_.isString(options.encryptionScheme)) {\n        this.$options.encryptionScheme = options.encryptionScheme.toLowerCase();\n        this.$options.encryptionSchemeOptions = {};\n      } else if (_.isObject(options.encryptionScheme)) {\n        this.$options.encryptionScheme = options.encryptionScheme.scheme || DEFAULT_ENCRYPTION_SCHEME;\n        this.$options.encryptionSchemeOptions = _.omit(options.encryptionScheme, 'scheme');\n      }\n\n      if (!schemes.isEncryption(this.$options.encryptionScheme)) {\n        throw Error('Unsupported encryption scheme');\n      }\n\n      if (this.$options.encryptionSchemeOptions.hash && SUPPORTED_HASH_ALGORITHMS[this.$options.environment].indexOf(this.$options.encryptionSchemeOptions.hash) === -1) {\n        throw Error('Unsupported hashing algorithm for ' + this.$options.environment + ' environment');\n      }\n    }\n\n    this.keyPair.setOptions(this.$options);\n  };\n  /**\n   * Generate private/public keys pair\n   *\n   * @param bits {int} length key in bits. Default 2048.\n   * @param exp {int} public exponent. Default 65537.\n   * @returns {NodeRSA}\n   */\n\n\n  NodeRSA.prototype.generateKeyPair = function (bits, exp) {\n    bits = bits || 2048;\n    exp = exp || 65537;\n\n    if (bits % 8 !== 0) {\n      throw Error('Key size must be a multiple of 8.');\n    }\n\n    this.keyPair.generate(bits, exp.toString(16));\n    this.$cache = {};\n    return this;\n  };\n  /**\n   * Importing key\n   * @param keyData {string|buffer|Object}\n   * @param format {string}\n   */\n\n\n  NodeRSA.prototype.importKey = function (keyData, format) {\n    if (!keyData) {\n      throw Error(\"Empty key given\");\n    }\n\n    if (format) {\n      format = EXPORT_FORMAT_ALIASES[format] || format;\n    }\n\n    if (!formats.detectAndImport(this.keyPair, keyData, format) && format === undefined) {\n      throw Error(\"Key format must be specified\");\n    }\n\n    this.$cache = {};\n    return this;\n  };\n  /**\n   * Exporting key\n   * @param [format] {string}\n   */\n\n\n  NodeRSA.prototype.exportKey = function (format) {\n    format = format || DEFAULT_EXPORT_FORMAT;\n    format = EXPORT_FORMAT_ALIASES[format] || format;\n\n    if (!this.$cache[format]) {\n      this.$cache[format] = formats.detectAndExport(this.keyPair, format);\n    }\n\n    return this.$cache[format];\n  };\n  /**\n   * Check if key pair contains private key\n   */\n\n\n  NodeRSA.prototype.isPrivate = function () {\n    return this.keyPair.isPrivate();\n  };\n  /**\n   * Check if key pair contains public key\n   * @param [strict] {boolean} - public key only, return false if have private exponent\n   */\n\n\n  NodeRSA.prototype.isPublic = function (strict) {\n    return this.keyPair.isPublic(strict);\n  };\n  /**\n   * Check if key pair doesn't contains any data\n   */\n\n\n  NodeRSA.prototype.isEmpty = function (strict) {\n    return !(this.keyPair.n || this.keyPair.e || this.keyPair.d);\n  };\n  /**\n   * Encrypting data method with public key\n   *\n   * @param buffer {string|number|object|array|Buffer} - data for encrypting. Object and array will convert to JSON string.\n   * @param encoding {string} - optional. Encoding for output result, may be 'buffer', 'binary', 'hex' or 'base64'. Default 'buffer'.\n   * @param source_encoding {string} - optional. Encoding for given string. Default utf8.\n   * @returns {string|Buffer}\n   */\n\n\n  NodeRSA.prototype.encrypt = function (buffer, encoding, source_encoding) {\n    return this.$$encryptKey(false, buffer, encoding, source_encoding);\n  };\n  /**\n   * Decrypting data method with private key\n   *\n   * @param buffer {Buffer} - buffer for decrypting\n   * @param encoding - encoding for result string, can also take 'json' or 'buffer' for the automatic conversion of this type\n   * @returns {Buffer|object|string}\n   */\n\n\n  NodeRSA.prototype.decrypt = function (buffer, encoding) {\n    return this.$$decryptKey(false, buffer, encoding);\n  };\n  /**\n   * Encrypting data method with private key\n   *\n   * Parameters same as `encrypt` method\n   */\n\n\n  NodeRSA.prototype.encryptPrivate = function (buffer, encoding, source_encoding) {\n    return this.$$encryptKey(true, buffer, encoding, source_encoding);\n  };\n  /**\n   * Decrypting data method with public key\n   *\n   * Parameters same as `decrypt` method\n   */\n\n\n  NodeRSA.prototype.decryptPublic = function (buffer, encoding) {\n    return this.$$decryptKey(true, buffer, encoding);\n  };\n  /**\n   * Encrypting data method with custom key\n   */\n\n\n  NodeRSA.prototype.$$encryptKey = function (usePrivate, buffer, encoding, source_encoding) {\n    try {\n      var res = this.keyPair.encrypt(this.$getDataForEncrypt(buffer, source_encoding), usePrivate);\n\n      if (encoding == 'buffer' || !encoding) {\n        return res;\n      } else {\n        return res.toString(encoding);\n      }\n    } catch (e) {\n      throw Error('Error during encryption. Original error: ' + e);\n    }\n  };\n  /**\n   * Decrypting data method with custom key\n   */\n\n\n  NodeRSA.prototype.$$decryptKey = function (usePublic, buffer, encoding) {\n    try {\n      buffer = _.isString(buffer) ? Buffer.from(buffer, 'base64') : buffer;\n      var res = this.keyPair.decrypt(buffer, usePublic);\n\n      if (res === null) {\n        throw Error('Key decrypt method returns null.');\n      }\n\n      return this.$getDecryptedData(res, encoding);\n    } catch (e) {\n      throw Error('Error during decryption (probably incorrect key). Original error: ' + e);\n    }\n  };\n  /**\n   *  Signing data\n   *\n   * @param buffer {string|number|object|array|Buffer} - data for signing. Object and array will convert to JSON string.\n   * @param encoding {string} - optional. Encoding for output result, may be 'buffer', 'binary', 'hex' or 'base64'. Default 'buffer'.\n   * @param source_encoding {string} - optional. Encoding for given string. Default utf8.\n   * @returns {string|Buffer}\n   */\n\n\n  NodeRSA.prototype.sign = function (buffer, encoding, source_encoding) {\n    if (!this.isPrivate()) {\n      throw Error(\"This is not private key\");\n    }\n\n    var res = this.keyPair.sign(this.$getDataForEncrypt(buffer, source_encoding));\n\n    if (encoding && encoding != 'buffer') {\n      res = res.toString(encoding);\n    }\n\n    return res;\n  };\n  /**\n   *  Verifying signed data\n   *\n   * @param buffer - signed data\n   * @param signature\n   * @param source_encoding {string} - optional. Encoding for given string. Default utf8.\n   * @param signature_encoding - optional. Encoding of given signature. May be 'buffer', 'binary', 'hex' or 'base64'. Default 'buffer'.\n   * @returns {*}\n   */\n\n\n  NodeRSA.prototype.verify = function (buffer, signature, source_encoding, signature_encoding) {\n    if (!this.isPublic()) {\n      throw Error(\"This is not public key\");\n    }\n\n    signature_encoding = !signature_encoding || signature_encoding == 'buffer' ? null : signature_encoding;\n    return this.keyPair.verify(this.$getDataForEncrypt(buffer, source_encoding), signature, signature_encoding);\n  };\n  /**\n   * Returns key size in bits\n   * @returns {int}\n   */\n\n\n  NodeRSA.prototype.getKeySize = function () {\n    return this.keyPair.keySize;\n  };\n  /**\n   * Returns max message length in bytes (for 1 chunk) depending on current encryption scheme\n   * @returns {int}\n   */\n\n\n  NodeRSA.prototype.getMaxMessageSize = function () {\n    return this.keyPair.maxMessageLength;\n  };\n  /**\n   * Preparing given data for encrypting/signing. Just make new/return Buffer object.\n   *\n   * @param buffer {string|number|object|array|Buffer} - data for encrypting. Object and array will convert to JSON string.\n   * @param encoding {string} - optional. Encoding for given string. Default utf8.\n   * @returns {Buffer}\n   */\n\n\n  NodeRSA.prototype.$getDataForEncrypt = function (buffer, encoding) {\n    if (_.isString(buffer) || _.isNumber(buffer)) {\n      return Buffer.from('' + buffer, encoding || 'utf8');\n    } else if (Buffer.isBuffer(buffer)) {\n      return buffer;\n    } else if (_.isObject(buffer)) {\n      return Buffer.from(JSON.stringify(buffer));\n    } else {\n      throw Error(\"Unexpected data type\");\n    }\n  };\n  /**\n   *\n   * @param buffer {Buffer} - decrypted data.\n   * @param encoding - optional. Encoding for result output. May be 'buffer', 'json' or any of Node.js Buffer supported encoding.\n   * @returns {*}\n   */\n\n\n  NodeRSA.prototype.$getDecryptedData = function (buffer, encoding) {\n    encoding = encoding || 'buffer';\n\n    if (encoding == 'buffer') {\n      return buffer;\n    } else if (encoding == 'json') {\n      return JSON.parse(buffer.toString());\n    } else {\n      return buffer.toString(encoding);\n    }\n  };\n\n  return NodeRSA;\n}();","map":{"version":3,"sources":["C:/Users/Zaman/zaman/RSA/front/node_modules/node-rsa/src/NodeRSA.js"],"names":["constants","require","rsa","crypt","ber","Ber","_","utils","schemes","formats","RSA_NO_PADDING","module","exports","SUPPORTED_HASH_ALGORITHMS","node10","node","iojs","browser","DEFAULT_ENCRYPTION_SCHEME","DEFAULT_SIGNING_SCHEME","DEFAULT_EXPORT_FORMAT","EXPORT_FORMAT_ALIASES","NodeRSA","key","format","options","isObject","undefined","$options","signingScheme","signingSchemeOptions","hash","saltLength","encryptionScheme","encryptionSchemeOptions","label","environment","detectEnvironment","rsaUtils","keyPair","Key","$cache","Buffer","isBuffer","isString","importKey","generateKeyPair","b","e","setOptions","prototype","toLowerCase","split","length","indexOf","scheme","omit","isSignature","Error","isEncryption","bits","exp","generate","toString","keyData","detectAndImport","exportKey","detectAndExport","isPrivate","isPublic","strict","isEmpty","n","d","encrypt","buffer","encoding","source_encoding","$$encryptKey","decrypt","$$decryptKey","encryptPrivate","decryptPublic","usePrivate","res","$getDataForEncrypt","usePublic","from","$getDecryptedData","sign","verify","signature","signature_encoding","getKeySize","keySize","getMaxMessageSize","maxMessageLength","isNumber","JSON","stringify","parse"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AAEA,IAAIA,SAAS,GAAGC,OAAO,CAAC,WAAD,CAAvB;;AACA,IAAIC,GAAG,GAAGD,OAAO,CAAC,eAAD,CAAjB;;AACA,IAAIE,KAAK,GAAGF,OAAO,CAAC,QAAD,CAAnB;;AACA,IAAIG,GAAG,GAAGH,OAAO,CAAC,MAAD,CAAP,CAAgBI,GAA1B;;AACA,IAAIC,CAAC,GAAGL,OAAO,CAAC,SAAD,CAAP,CAAmBK,CAA3B;;AACA,IAAIC,KAAK,GAAGN,OAAO,CAAC,SAAD,CAAnB;;AACA,IAAIO,OAAO,GAAGP,OAAO,CAAC,sBAAD,CAArB;;AACA,IAAIQ,OAAO,GAAGR,OAAO,CAAC,sBAAD,CAArB;;AAEA,IAAI,OAAOD,SAAS,CAACU,cAAjB,KAAoC,WAAxC,EAAqD;AACjD;AACAV,EAAAA,SAAS,CAACU,cAAV,GAA2B,CAA3B;AACH;;AAEDC,MAAM,CAACC,OAAP,GAAkB,YAAY;AAC1B,MAAIC,yBAAyB,GAAG;AAC5BC,IAAAA,MAAM,EAAE,CAAC,KAAD,EAAQ,KAAR,EAAe,WAAf,EAA4B,MAA5B,EAAoC,QAApC,EAA8C,QAA9C,EAAwD,QAAxD,EAAkE,QAAlE,CADoB;AAE5BC,IAAAA,IAAI,EAAE,CAAC,KAAD,EAAQ,KAAR,EAAe,WAAf,EAA4B,MAA5B,EAAoC,QAApC,EAA8C,QAA9C,EAAwD,QAAxD,EAAkE,QAAlE,CAFsB;AAG5BC,IAAAA,IAAI,EAAE,CAAC,KAAD,EAAQ,KAAR,EAAe,WAAf,EAA4B,MAA5B,EAAoC,QAApC,EAA8C,QAA9C,EAAwD,QAAxD,EAAkE,QAAlE,CAHsB;AAI5BC,IAAAA,OAAO,EAAE,CAAC,KAAD,EAAQ,WAAR,EAAqB,MAArB,EAA6B,QAA7B,EAAuC,QAAvC;AAJmB,GAAhC;AAOA,MAAIC,yBAAyB,GAAG,YAAhC;AACA,MAAIC,sBAAsB,GAAG,OAA7B;AAEA,MAAIC,qBAAqB,GAAG,SAA5B;AACA,MAAIC,qBAAqB,GAAG;AACxB,eAAW,mBADa;AAExB,mBAAe,mBAFS;AAGxB,cAAU,kBAHc;AAIxB,kBAAc;AAJU,GAA5B;AAOA;AACJ;AACA;AACA;;AACI,WAASC,OAAT,CAAiBC,GAAjB,EAAsBC,MAAtB,EAA8BC,OAA9B,EAAuC;AACnC,QAAI,EAAE,gBAAgBH,OAAlB,CAAJ,EAAgC;AAC5B,aAAO,IAAIA,OAAJ,CAAYC,GAAZ,EAAiBC,MAAjB,EAAyBC,OAAzB,CAAP;AACH;;AAED,QAAInB,CAAC,CAACoB,QAAF,CAAWF,MAAX,CAAJ,EAAwB;AACpBC,MAAAA,OAAO,GAAGD,MAAV;AACAA,MAAAA,MAAM,GAAGG,SAAT;AACH;;AAED,SAAKC,QAAL,GAAgB;AACZC,MAAAA,aAAa,EAAEV,sBADH;AAEZW,MAAAA,oBAAoB,EAAE;AAClBC,QAAAA,IAAI,EAAE,QADY;AAElBC,QAAAA,UAAU,EAAE;AAFM,OAFV;AAMZC,MAAAA,gBAAgB,EAAEf,yBANN;AAOZgB,MAAAA,uBAAuB,EAAE;AACrBH,QAAAA,IAAI,EAAE,MADe;AAErBI,QAAAA,KAAK,EAAE;AAFc,OAPb;AAWZC,MAAAA,WAAW,EAAE7B,KAAK,CAAC8B,iBAAN,EAXD;AAYZC,MAAAA,QAAQ,EAAE;AAZE,KAAhB;AAcA,SAAKC,OAAL,GAAe,IAAIrC,GAAG,CAACsC,GAAR,EAAf;AACA,SAAKC,MAAL,GAAc,EAAd;;AAEA,QAAIC,MAAM,CAACC,QAAP,CAAgBpB,GAAhB,KAAwBjB,CAAC,CAACsC,QAAF,CAAWrB,GAAX,CAA5B,EAA6C;AACzC,WAAKsB,SAAL,CAAetB,GAAf,EAAoBC,MAApB;AACH,KAFD,MAEO,IAAIlB,CAAC,CAACoB,QAAF,CAAWH,GAAX,CAAJ,EAAqB;AACxB,WAAKuB,eAAL,CAAqBvB,GAAG,CAACwB,CAAzB,EAA4BxB,GAAG,CAACyB,CAAhC;AACH;;AAED,SAAKC,UAAL,CAAgBxB,OAAhB;AACH;AAED;AACJ;AACA;AACA;;;AACIH,EAAAA,OAAO,CAAC4B,SAAR,CAAkBD,UAAlB,GAA+B,UAAUxB,OAAV,EAAmB;AAC9CA,IAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;;AACA,QAAIA,OAAO,CAACW,WAAZ,EAAyB;AACrB,WAAKR,QAAL,CAAcQ,WAAd,GAA4BX,OAAO,CAACW,WAApC;AACH;;AAED,QAAIX,OAAO,CAACI,aAAZ,EAA2B;AACvB,UAAIvB,CAAC,CAACsC,QAAF,CAAWnB,OAAO,CAACI,aAAnB,CAAJ,EAAuC;AACnC,YAAIA,aAAa,GAAGJ,OAAO,CAACI,aAAR,CAAsBsB,WAAtB,GAAoCC,KAApC,CAA0C,GAA1C,CAApB;;AACA,YAAIvB,aAAa,CAACwB,MAAd,IAAwB,CAA5B,EAA+B;AAC3B,cAAIxC,yBAAyB,CAACE,IAA1B,CAA+BuC,OAA/B,CAAuCzB,aAAa,CAAC,CAAD,CAApD,IAA2D,CAAC,CAAhE,EAAmE;AAC/D,iBAAKD,QAAL,CAAcE,oBAAd,GAAqC;AACjCC,cAAAA,IAAI,EAAEF,aAAa,CAAC,CAAD;AADc,aAArC;AAGA,iBAAKD,QAAL,CAAcC,aAAd,GAA8BV,sBAA9B;AACH,WALD,MAKO;AACH,iBAAKS,QAAL,CAAcC,aAAd,GAA8BA,aAAa,CAAC,CAAD,CAA3C;AACA,iBAAKD,QAAL,CAAcE,oBAAd,GAAqC;AACjCC,cAAAA,IAAI,EAAE;AAD2B,aAArC;AAGH;AACJ,SAZD,MAYO;AACH,eAAKH,QAAL,CAAcE,oBAAd,GAAqC;AACjCC,YAAAA,IAAI,EAAEF,aAAa,CAAC,CAAD;AADc,WAArC;AAGA,eAAKD,QAAL,CAAcC,aAAd,GAA8BA,aAAa,CAAC,CAAD,CAA3C;AACH;AACJ,OApBD,MAoBO,IAAIvB,CAAC,CAACoB,QAAF,CAAWD,OAAO,CAACI,aAAnB,CAAJ,EAAuC;AAC1C,aAAKD,QAAL,CAAcC,aAAd,GAA8BJ,OAAO,CAACI,aAAR,CAAsB0B,MAAtB,IAAgCpC,sBAA9D;AACA,aAAKS,QAAL,CAAcE,oBAAd,GAAqCxB,CAAC,CAACkD,IAAF,CAAO/B,OAAO,CAACI,aAAf,EAA8B,QAA9B,CAArC;AACH;;AAED,UAAI,CAACrB,OAAO,CAACiD,WAAR,CAAoB,KAAK7B,QAAL,CAAcC,aAAlC,CAAL,EAAuD;AACnD,cAAM6B,KAAK,CAAC,4BAAD,CAAX;AACH;;AAED,UAAI,KAAK9B,QAAL,CAAcE,oBAAd,CAAmCC,IAAnC,IACAlB,yBAAyB,CAAC,KAAKe,QAAL,CAAcQ,WAAf,CAAzB,CAAqDkB,OAArD,CAA6D,KAAK1B,QAAL,CAAcE,oBAAd,CAAmCC,IAAhG,MAA0G,CAAC,CAD/G,EACkH;AAC9G,cAAM2B,KAAK,CAAC,uCAAuC,KAAK9B,QAAL,CAAcQ,WAArD,GAAmE,cAApE,CAAX;AACH;AACJ;;AAED,QAAIX,OAAO,CAACQ,gBAAZ,EAA8B;AAC1B,UAAI3B,CAAC,CAACsC,QAAF,CAAWnB,OAAO,CAACQ,gBAAnB,CAAJ,EAA0C;AACtC,aAAKL,QAAL,CAAcK,gBAAd,GAAiCR,OAAO,CAACQ,gBAAR,CAAyBkB,WAAzB,EAAjC;AACA,aAAKvB,QAAL,CAAcM,uBAAd,GAAwC,EAAxC;AACH,OAHD,MAGO,IAAI5B,CAAC,CAACoB,QAAF,CAAWD,OAAO,CAACQ,gBAAnB,CAAJ,EAA0C;AAC7C,aAAKL,QAAL,CAAcK,gBAAd,GAAiCR,OAAO,CAACQ,gBAAR,CAAyBsB,MAAzB,IAAmCrC,yBAApE;AACA,aAAKU,QAAL,CAAcM,uBAAd,GAAwC5B,CAAC,CAACkD,IAAF,CAAO/B,OAAO,CAACQ,gBAAf,EAAiC,QAAjC,CAAxC;AACH;;AAED,UAAI,CAACzB,OAAO,CAACmD,YAAR,CAAqB,KAAK/B,QAAL,CAAcK,gBAAnC,CAAL,EAA2D;AACvD,cAAMyB,KAAK,CAAC,+BAAD,CAAX;AACH;;AAED,UAAI,KAAK9B,QAAL,CAAcM,uBAAd,CAAsCH,IAAtC,IACAlB,yBAAyB,CAAC,KAAKe,QAAL,CAAcQ,WAAf,CAAzB,CAAqDkB,OAArD,CAA6D,KAAK1B,QAAL,CAAcM,uBAAd,CAAsCH,IAAnG,MAA6G,CAAC,CADlH,EACqH;AACjH,cAAM2B,KAAK,CAAC,uCAAuC,KAAK9B,QAAL,CAAcQ,WAArD,GAAmE,cAApE,CAAX;AACH;AACJ;;AAED,SAAKG,OAAL,CAAaU,UAAb,CAAwB,KAAKrB,QAA7B;AACH,GA9DD;AAgEA;AACJ;AACA;AACA;AACA;AACA;AACA;;;AACIN,EAAAA,OAAO,CAAC4B,SAAR,CAAkBJ,eAAlB,GAAoC,UAAUc,IAAV,EAAgBC,GAAhB,EAAqB;AACrDD,IAAAA,IAAI,GAAGA,IAAI,IAAI,IAAf;AACAC,IAAAA,GAAG,GAAGA,GAAG,IAAI,KAAb;;AAEA,QAAID,IAAI,GAAG,CAAP,KAAa,CAAjB,EAAoB;AAChB,YAAMF,KAAK,CAAC,mCAAD,CAAX;AACH;;AAED,SAAKnB,OAAL,CAAauB,QAAb,CAAsBF,IAAtB,EAA4BC,GAAG,CAACE,QAAJ,CAAa,EAAb,CAA5B;AACA,SAAKtB,MAAL,GAAc,EAAd;AACA,WAAO,IAAP;AACH,GAXD;AAaA;AACJ;AACA;AACA;AACA;;;AACInB,EAAAA,OAAO,CAAC4B,SAAR,CAAkBL,SAAlB,GAA8B,UAAUmB,OAAV,EAAmBxC,MAAnB,EAA2B;AACrD,QAAI,CAACwC,OAAL,EAAc;AACV,YAAMN,KAAK,CAAC,iBAAD,CAAX;AACH;;AAED,QAAIlC,MAAJ,EAAY;AACRA,MAAAA,MAAM,GAAGH,qBAAqB,CAACG,MAAD,CAArB,IAAiCA,MAA1C;AACH;;AAED,QAAI,CAACf,OAAO,CAACwD,eAAR,CAAwB,KAAK1B,OAA7B,EAAsCyB,OAAtC,EAA+CxC,MAA/C,CAAD,IAA2DA,MAAM,KAAKG,SAA1E,EAAqF;AACjF,YAAM+B,KAAK,CAAC,8BAAD,CAAX;AACH;;AAED,SAAKjB,MAAL,GAAc,EAAd;AAEA,WAAO,IAAP;AACH,GAhBD;AAkBA;AACJ;AACA;AACA;;;AACInB,EAAAA,OAAO,CAAC4B,SAAR,CAAkBgB,SAAlB,GAA8B,UAAU1C,MAAV,EAAkB;AAC5CA,IAAAA,MAAM,GAAGA,MAAM,IAAIJ,qBAAnB;AACAI,IAAAA,MAAM,GAAGH,qBAAqB,CAACG,MAAD,CAArB,IAAiCA,MAA1C;;AAEA,QAAI,CAAC,KAAKiB,MAAL,CAAYjB,MAAZ,CAAL,EAA0B;AACtB,WAAKiB,MAAL,CAAYjB,MAAZ,IAAsBf,OAAO,CAAC0D,eAAR,CAAwB,KAAK5B,OAA7B,EAAsCf,MAAtC,CAAtB;AACH;;AAED,WAAO,KAAKiB,MAAL,CAAYjB,MAAZ,CAAP;AACH,GATD;AAWA;AACJ;AACA;;;AACIF,EAAAA,OAAO,CAAC4B,SAAR,CAAkBkB,SAAlB,GAA8B,YAAY;AACtC,WAAO,KAAK7B,OAAL,CAAa6B,SAAb,EAAP;AACH,GAFD;AAIA;AACJ;AACA;AACA;;;AACI9C,EAAAA,OAAO,CAAC4B,SAAR,CAAkBmB,QAAlB,GAA6B,UAAUC,MAAV,EAAkB;AAC3C,WAAO,KAAK/B,OAAL,CAAa8B,QAAb,CAAsBC,MAAtB,CAAP;AACH,GAFD;AAIA;AACJ;AACA;;;AACIhD,EAAAA,OAAO,CAAC4B,SAAR,CAAkBqB,OAAlB,GAA4B,UAAUD,MAAV,EAAkB;AAC1C,WAAO,EAAE,KAAK/B,OAAL,CAAaiC,CAAb,IAAkB,KAAKjC,OAAL,CAAaS,CAA/B,IAAoC,KAAKT,OAAL,CAAakC,CAAnD,CAAP;AACH,GAFD;AAIA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;AACInD,EAAAA,OAAO,CAAC4B,SAAR,CAAkBwB,OAAlB,GAA4B,UAAUC,MAAV,EAAkBC,QAAlB,EAA4BC,eAA5B,EAA6C;AACrE,WAAO,KAAKC,YAAL,CAAkB,KAAlB,EAAyBH,MAAzB,EAAiCC,QAAjC,EAA2CC,eAA3C,CAAP;AACH,GAFD;AAIA;AACJ;AACA;AACA;AACA;AACA;AACA;;;AACIvD,EAAAA,OAAO,CAAC4B,SAAR,CAAkB6B,OAAlB,GAA4B,UAAUJ,MAAV,EAAkBC,QAAlB,EAA4B;AACpD,WAAO,KAAKI,YAAL,CAAkB,KAAlB,EAAyBL,MAAzB,EAAiCC,QAAjC,CAAP;AACH,GAFD;AAIA;AACJ;AACA;AACA;AACA;;;AACItD,EAAAA,OAAO,CAAC4B,SAAR,CAAkB+B,cAAlB,GAAmC,UAAUN,MAAV,EAAkBC,QAAlB,EAA4BC,eAA5B,EAA6C;AAC5E,WAAO,KAAKC,YAAL,CAAkB,IAAlB,EAAwBH,MAAxB,EAAgCC,QAAhC,EAA0CC,eAA1C,CAAP;AACH,GAFD;AAIA;AACJ;AACA;AACA;AACA;;;AACIvD,EAAAA,OAAO,CAAC4B,SAAR,CAAkBgC,aAAlB,GAAkC,UAAUP,MAAV,EAAkBC,QAAlB,EAA4B;AAC1D,WAAO,KAAKI,YAAL,CAAkB,IAAlB,EAAwBL,MAAxB,EAAgCC,QAAhC,CAAP;AACH,GAFD;AAIA;AACJ;AACA;;;AACItD,EAAAA,OAAO,CAAC4B,SAAR,CAAkB4B,YAAlB,GAAiC,UAAUK,UAAV,EAAsBR,MAAtB,EAA8BC,QAA9B,EAAwCC,eAAxC,EAAyD;AACtF,QAAI;AACA,UAAIO,GAAG,GAAG,KAAK7C,OAAL,CAAamC,OAAb,CAAqB,KAAKW,kBAAL,CAAwBV,MAAxB,EAAgCE,eAAhC,CAArB,EAAuEM,UAAvE,CAAV;;AAEA,UAAIP,QAAQ,IAAI,QAAZ,IAAwB,CAACA,QAA7B,EAAuC;AACnC,eAAOQ,GAAP;AACH,OAFD,MAEO;AACH,eAAOA,GAAG,CAACrB,QAAJ,CAAaa,QAAb,CAAP;AACH;AACJ,KARD,CAQE,OAAO5B,CAAP,EAAU;AACR,YAAMU,KAAK,CAAC,8CAA8CV,CAA/C,CAAX;AACH;AACJ,GAZD;AAcA;AACJ;AACA;;;AACI1B,EAAAA,OAAO,CAAC4B,SAAR,CAAkB8B,YAAlB,GAAiC,UAAUM,SAAV,EAAqBX,MAArB,EAA6BC,QAA7B,EAAuC;AACpE,QAAI;AACAD,MAAAA,MAAM,GAAGrE,CAAC,CAACsC,QAAF,CAAW+B,MAAX,IAAqBjC,MAAM,CAAC6C,IAAP,CAAYZ,MAAZ,EAAoB,QAApB,CAArB,GAAqDA,MAA9D;AACA,UAAIS,GAAG,GAAG,KAAK7C,OAAL,CAAawC,OAAb,CAAqBJ,MAArB,EAA6BW,SAA7B,CAAV;;AAEA,UAAIF,GAAG,KAAK,IAAZ,EAAkB;AACd,cAAM1B,KAAK,CAAC,kCAAD,CAAX;AACH;;AAED,aAAO,KAAK8B,iBAAL,CAAuBJ,GAAvB,EAA4BR,QAA5B,CAAP;AACH,KATD,CASE,OAAO5B,CAAP,EAAU;AACR,YAAMU,KAAK,CAAC,uEAAuEV,CAAxE,CAAX;AACH;AACJ,GAbD;AAeA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI1B,EAAAA,OAAO,CAAC4B,SAAR,CAAkBuC,IAAlB,GAAyB,UAAUd,MAAV,EAAkBC,QAAlB,EAA4BC,eAA5B,EAA6C;AAClE,QAAI,CAAC,KAAKT,SAAL,EAAL,EAAuB;AACnB,YAAMV,KAAK,CAAC,yBAAD,CAAX;AACH;;AAED,QAAI0B,GAAG,GAAG,KAAK7C,OAAL,CAAakD,IAAb,CAAkB,KAAKJ,kBAAL,CAAwBV,MAAxB,EAAgCE,eAAhC,CAAlB,CAAV;;AAEA,QAAID,QAAQ,IAAIA,QAAQ,IAAI,QAA5B,EAAsC;AAClCQ,MAAAA,GAAG,GAAGA,GAAG,CAACrB,QAAJ,CAAaa,QAAb,CAAN;AACH;;AAED,WAAOQ,GAAP;AACH,GAZD;AAcA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI9D,EAAAA,OAAO,CAAC4B,SAAR,CAAkBwC,MAAlB,GAA2B,UAAUf,MAAV,EAAkBgB,SAAlB,EAA6Bd,eAA7B,EAA8Ce,kBAA9C,EAAkE;AACzF,QAAI,CAAC,KAAKvB,QAAL,EAAL,EAAsB;AAClB,YAAMX,KAAK,CAAC,wBAAD,CAAX;AACH;;AACDkC,IAAAA,kBAAkB,GAAI,CAACA,kBAAD,IAAuBA,kBAAkB,IAAI,QAA7C,GAAwD,IAAxD,GAA+DA,kBAArF;AACA,WAAO,KAAKrD,OAAL,CAAamD,MAAb,CAAoB,KAAKL,kBAAL,CAAwBV,MAAxB,EAAgCE,eAAhC,CAApB,EAAsEc,SAAtE,EAAiFC,kBAAjF,CAAP;AACH,GAND;AAQA;AACJ;AACA;AACA;;;AACItE,EAAAA,OAAO,CAAC4B,SAAR,CAAkB2C,UAAlB,GAA+B,YAAY;AACvC,WAAO,KAAKtD,OAAL,CAAauD,OAApB;AACH,GAFD;AAIA;AACJ;AACA;AACA;;;AACIxE,EAAAA,OAAO,CAAC4B,SAAR,CAAkB6C,iBAAlB,GAAsC,YAAY;AAC9C,WAAO,KAAKxD,OAAL,CAAayD,gBAApB;AACH,GAFD;AAIA;AACJ;AACA;AACA;AACA;AACA;AACA;;;AACI1E,EAAAA,OAAO,CAAC4B,SAAR,CAAkBmC,kBAAlB,GAAuC,UAAUV,MAAV,EAAkBC,QAAlB,EAA4B;AAC/D,QAAItE,CAAC,CAACsC,QAAF,CAAW+B,MAAX,KAAsBrE,CAAC,CAAC2F,QAAF,CAAWtB,MAAX,CAA1B,EAA8C;AAC1C,aAAOjC,MAAM,CAAC6C,IAAP,CAAY,KAAKZ,MAAjB,EAAyBC,QAAQ,IAAI,MAArC,CAAP;AACH,KAFD,MAEO,IAAIlC,MAAM,CAACC,QAAP,CAAgBgC,MAAhB,CAAJ,EAA6B;AAChC,aAAOA,MAAP;AACH,KAFM,MAEA,IAAIrE,CAAC,CAACoB,QAAF,CAAWiD,MAAX,CAAJ,EAAwB;AAC3B,aAAOjC,MAAM,CAAC6C,IAAP,CAAYW,IAAI,CAACC,SAAL,CAAexB,MAAf,CAAZ,CAAP;AACH,KAFM,MAEA;AACH,YAAMjB,KAAK,CAAC,sBAAD,CAAX;AACH;AACJ,GAVD;AAYA;AACJ;AACA;AACA;AACA;AACA;;;AACIpC,EAAAA,OAAO,CAAC4B,SAAR,CAAkBsC,iBAAlB,GAAsC,UAAUb,MAAV,EAAkBC,QAAlB,EAA4B;AAC9DA,IAAAA,QAAQ,GAAGA,QAAQ,IAAI,QAAvB;;AAEA,QAAIA,QAAQ,IAAI,QAAhB,EAA0B;AACtB,aAAOD,MAAP;AACH,KAFD,MAEO,IAAIC,QAAQ,IAAI,MAAhB,EAAwB;AAC3B,aAAOsB,IAAI,CAACE,KAAL,CAAWzB,MAAM,CAACZ,QAAP,EAAX,CAAP;AACH,KAFM,MAEA;AACH,aAAOY,MAAM,CAACZ,QAAP,CAAgBa,QAAhB,CAAP;AACH;AACJ,GAVD;;AAYA,SAAOtD,OAAP;AACH,CAxXgB,EAAjB","sourcesContent":["/*!\n * RSA library for Node.js\n *\n * Author: rzcoder\n * License MIT\n */\n\nvar constants = require('constants');\nvar rsa = require('./libs/rsa.js');\nvar crypt = require('crypto');\nvar ber = require('asn1').Ber;\nvar _ = require('./utils')._;\nvar utils = require('./utils');\nvar schemes = require('./schemes/schemes.js');\nvar formats = require('./formats/formats.js');\n\nif (typeof constants.RSA_NO_PADDING === \"undefined\") {\n    //patch for node v0.10.x, constants do not defined\n    constants.RSA_NO_PADDING = 3;\n}\n\nmodule.exports = (function () {\n    var SUPPORTED_HASH_ALGORITHMS = {\n        node10: ['md4', 'md5', 'ripemd160', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512'],\n        node: ['md4', 'md5', 'ripemd160', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512'],\n        iojs: ['md4', 'md5', 'ripemd160', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512'],\n        browser: ['md5', 'ripemd160', 'sha1', 'sha256', 'sha512']\n    };\n\n    var DEFAULT_ENCRYPTION_SCHEME = 'pkcs1_oaep';\n    var DEFAULT_SIGNING_SCHEME = 'pkcs1';\n\n    var DEFAULT_EXPORT_FORMAT = 'private';\n    var EXPORT_FORMAT_ALIASES = {\n        'private': 'pkcs1-private-pem',\n        'private-der': 'pkcs1-private-der',\n        'public': 'pkcs8-public-pem',\n        'public-der': 'pkcs8-public-der',\n    };\n\n    /**\n     * @param key {string|buffer|object} Key in PEM format, or data for generate key {b: bits, e: exponent}\n     * @constructor\n     */\n    function NodeRSA(key, format, options) {\n        if (!(this instanceof NodeRSA)) {\n            return new NodeRSA(key, format, options);\n        }\n\n        if (_.isObject(format)) {\n            options = format;\n            format = undefined;\n        }\n\n        this.$options = {\n            signingScheme: DEFAULT_SIGNING_SCHEME,\n            signingSchemeOptions: {\n                hash: 'sha256',\n                saltLength: null\n            },\n            encryptionScheme: DEFAULT_ENCRYPTION_SCHEME,\n            encryptionSchemeOptions: {\n                hash: 'sha1',\n                label: null\n            },\n            environment: utils.detectEnvironment(),\n            rsaUtils: this\n        };\n        this.keyPair = new rsa.Key();\n        this.$cache = {};\n\n        if (Buffer.isBuffer(key) || _.isString(key)) {\n            this.importKey(key, format);\n        } else if (_.isObject(key)) {\n            this.generateKeyPair(key.b, key.e);\n        }\n\n        this.setOptions(options);\n    }\n\n    /**\n     * Set and validate options for key instance\n     * @param options\n     */\n    NodeRSA.prototype.setOptions = function (options) {\n        options = options || {};\n        if (options.environment) {\n            this.$options.environment = options.environment;\n        }\n\n        if (options.signingScheme) {\n            if (_.isString(options.signingScheme)) {\n                var signingScheme = options.signingScheme.toLowerCase().split('-');\n                if (signingScheme.length == 1) {\n                    if (SUPPORTED_HASH_ALGORITHMS.node.indexOf(signingScheme[0]) > -1) {\n                        this.$options.signingSchemeOptions = {\n                            hash: signingScheme[0]\n                        };\n                        this.$options.signingScheme = DEFAULT_SIGNING_SCHEME;\n                    } else {\n                        this.$options.signingScheme = signingScheme[0];\n                        this.$options.signingSchemeOptions = {\n                            hash: null\n                        };\n                    }\n                } else {\n                    this.$options.signingSchemeOptions = {\n                        hash: signingScheme[1]\n                    };\n                    this.$options.signingScheme = signingScheme[0];\n                }\n            } else if (_.isObject(options.signingScheme)) {\n                this.$options.signingScheme = options.signingScheme.scheme || DEFAULT_SIGNING_SCHEME;\n                this.$options.signingSchemeOptions = _.omit(options.signingScheme, 'scheme');\n            }\n\n            if (!schemes.isSignature(this.$options.signingScheme)) {\n                throw Error('Unsupported signing scheme');\n            }\n\n            if (this.$options.signingSchemeOptions.hash &&\n                SUPPORTED_HASH_ALGORITHMS[this.$options.environment].indexOf(this.$options.signingSchemeOptions.hash) === -1) {\n                throw Error('Unsupported hashing algorithm for ' + this.$options.environment + ' environment');\n            }\n        }\n\n        if (options.encryptionScheme) {\n            if (_.isString(options.encryptionScheme)) {\n                this.$options.encryptionScheme = options.encryptionScheme.toLowerCase();\n                this.$options.encryptionSchemeOptions = {};\n            } else if (_.isObject(options.encryptionScheme)) {\n                this.$options.encryptionScheme = options.encryptionScheme.scheme || DEFAULT_ENCRYPTION_SCHEME;\n                this.$options.encryptionSchemeOptions = _.omit(options.encryptionScheme, 'scheme');\n            }\n\n            if (!schemes.isEncryption(this.$options.encryptionScheme)) {\n                throw Error('Unsupported encryption scheme');\n            }\n\n            if (this.$options.encryptionSchemeOptions.hash &&\n                SUPPORTED_HASH_ALGORITHMS[this.$options.environment].indexOf(this.$options.encryptionSchemeOptions.hash) === -1) {\n                throw Error('Unsupported hashing algorithm for ' + this.$options.environment + ' environment');\n            }\n        }\n\n        this.keyPair.setOptions(this.$options);\n    };\n\n    /**\n     * Generate private/public keys pair\n     *\n     * @param bits {int} length key in bits. Default 2048.\n     * @param exp {int} public exponent. Default 65537.\n     * @returns {NodeRSA}\n     */\n    NodeRSA.prototype.generateKeyPair = function (bits, exp) {\n        bits = bits || 2048;\n        exp = exp || 65537;\n\n        if (bits % 8 !== 0) {\n            throw Error('Key size must be a multiple of 8.');\n        }\n\n        this.keyPair.generate(bits, exp.toString(16));\n        this.$cache = {};\n        return this;\n    };\n\n    /**\n     * Importing key\n     * @param keyData {string|buffer|Object}\n     * @param format {string}\n     */\n    NodeRSA.prototype.importKey = function (keyData, format) {\n        if (!keyData) {\n            throw Error(\"Empty key given\");\n        }\n\n        if (format) {\n            format = EXPORT_FORMAT_ALIASES[format] || format;\n        }\n\n        if (!formats.detectAndImport(this.keyPair, keyData, format) && format === undefined) {\n            throw Error(\"Key format must be specified\");\n        }\n        \n        this.$cache = {};\n        \n        return this;\n    };\n\n    /**\n     * Exporting key\n     * @param [format] {string}\n     */\n    NodeRSA.prototype.exportKey = function (format) {\n        format = format || DEFAULT_EXPORT_FORMAT;\n        format = EXPORT_FORMAT_ALIASES[format] || format;\n\n        if (!this.$cache[format]) {\n            this.$cache[format] = formats.detectAndExport(this.keyPair, format);\n        }\n\n        return this.$cache[format];\n    };\n\n    /**\n     * Check if key pair contains private key\n     */\n    NodeRSA.prototype.isPrivate = function () {\n        return this.keyPair.isPrivate();\n    };\n\n    /**\n     * Check if key pair contains public key\n     * @param [strict] {boolean} - public key only, return false if have private exponent\n     */\n    NodeRSA.prototype.isPublic = function (strict) {\n        return this.keyPair.isPublic(strict);\n    };\n\n    /**\n     * Check if key pair doesn't contains any data\n     */\n    NodeRSA.prototype.isEmpty = function (strict) {\n        return !(this.keyPair.n || this.keyPair.e || this.keyPair.d);\n    };\n\n    /**\n     * Encrypting data method with public key\n     *\n     * @param buffer {string|number|object|array|Buffer} - data for encrypting. Object and array will convert to JSON string.\n     * @param encoding {string} - optional. Encoding for output result, may be 'buffer', 'binary', 'hex' or 'base64'. Default 'buffer'.\n     * @param source_encoding {string} - optional. Encoding for given string. Default utf8.\n     * @returns {string|Buffer}\n     */\n    NodeRSA.prototype.encrypt = function (buffer, encoding, source_encoding) {\n        return this.$$encryptKey(false, buffer, encoding, source_encoding);\n    };\n\n    /**\n     * Decrypting data method with private key\n     *\n     * @param buffer {Buffer} - buffer for decrypting\n     * @param encoding - encoding for result string, can also take 'json' or 'buffer' for the automatic conversion of this type\n     * @returns {Buffer|object|string}\n     */\n    NodeRSA.prototype.decrypt = function (buffer, encoding) {\n        return this.$$decryptKey(false, buffer, encoding);\n    };\n\n    /**\n     * Encrypting data method with private key\n     *\n     * Parameters same as `encrypt` method\n     */\n    NodeRSA.prototype.encryptPrivate = function (buffer, encoding, source_encoding) {\n        return this.$$encryptKey(true, buffer, encoding, source_encoding);\n    };\n\n    /**\n     * Decrypting data method with public key\n     *\n     * Parameters same as `decrypt` method\n     */\n    NodeRSA.prototype.decryptPublic = function (buffer, encoding) {\n        return this.$$decryptKey(true, buffer, encoding);\n    };\n\n    /**\n     * Encrypting data method with custom key\n     */\n    NodeRSA.prototype.$$encryptKey = function (usePrivate, buffer, encoding, source_encoding) {\n        try {\n            var res = this.keyPair.encrypt(this.$getDataForEncrypt(buffer, source_encoding), usePrivate);\n\n            if (encoding == 'buffer' || !encoding) {\n                return res;\n            } else {\n                return res.toString(encoding);\n            }\n        } catch (e) {\n            throw Error('Error during encryption. Original error: ' + e);\n        }\n    };\n\n    /**\n     * Decrypting data method with custom key\n     */\n    NodeRSA.prototype.$$decryptKey = function (usePublic, buffer, encoding) {\n        try {\n            buffer = _.isString(buffer) ? Buffer.from(buffer, 'base64') : buffer;\n            var res = this.keyPair.decrypt(buffer, usePublic);\n\n            if (res === null) {\n                throw Error('Key decrypt method returns null.');\n            }\n\n            return this.$getDecryptedData(res, encoding);\n        } catch (e) {\n            throw Error('Error during decryption (probably incorrect key). Original error: ' + e);\n        }\n    };\n\n    /**\n     *  Signing data\n     *\n     * @param buffer {string|number|object|array|Buffer} - data for signing. Object and array will convert to JSON string.\n     * @param encoding {string} - optional. Encoding for output result, may be 'buffer', 'binary', 'hex' or 'base64'. Default 'buffer'.\n     * @param source_encoding {string} - optional. Encoding for given string. Default utf8.\n     * @returns {string|Buffer}\n     */\n    NodeRSA.prototype.sign = function (buffer, encoding, source_encoding) {\n        if (!this.isPrivate()) {\n            throw Error(\"This is not private key\");\n        }\n\n        var res = this.keyPair.sign(this.$getDataForEncrypt(buffer, source_encoding));\n\n        if (encoding && encoding != 'buffer') {\n            res = res.toString(encoding);\n        }\n\n        return res;\n    };\n\n    /**\n     *  Verifying signed data\n     *\n     * @param buffer - signed data\n     * @param signature\n     * @param source_encoding {string} - optional. Encoding for given string. Default utf8.\n     * @param signature_encoding - optional. Encoding of given signature. May be 'buffer', 'binary', 'hex' or 'base64'. Default 'buffer'.\n     * @returns {*}\n     */\n    NodeRSA.prototype.verify = function (buffer, signature, source_encoding, signature_encoding) {\n        if (!this.isPublic()) {\n            throw Error(\"This is not public key\");\n        }\n        signature_encoding = (!signature_encoding || signature_encoding == 'buffer' ? null : signature_encoding);\n        return this.keyPair.verify(this.$getDataForEncrypt(buffer, source_encoding), signature, signature_encoding);\n    };\n\n    /**\n     * Returns key size in bits\n     * @returns {int}\n     */\n    NodeRSA.prototype.getKeySize = function () {\n        return this.keyPair.keySize;\n    };\n\n    /**\n     * Returns max message length in bytes (for 1 chunk) depending on current encryption scheme\n     * @returns {int}\n     */\n    NodeRSA.prototype.getMaxMessageSize = function () {\n        return this.keyPair.maxMessageLength;\n    };\n\n    /**\n     * Preparing given data for encrypting/signing. Just make new/return Buffer object.\n     *\n     * @param buffer {string|number|object|array|Buffer} - data for encrypting. Object and array will convert to JSON string.\n     * @param encoding {string} - optional. Encoding for given string. Default utf8.\n     * @returns {Buffer}\n     */\n    NodeRSA.prototype.$getDataForEncrypt = function (buffer, encoding) {\n        if (_.isString(buffer) || _.isNumber(buffer)) {\n            return Buffer.from('' + buffer, encoding || 'utf8');\n        } else if (Buffer.isBuffer(buffer)) {\n            return buffer;\n        } else if (_.isObject(buffer)) {\n            return Buffer.from(JSON.stringify(buffer));\n        } else {\n            throw Error(\"Unexpected data type\");\n        }\n    };\n\n    /**\n     *\n     * @param buffer {Buffer} - decrypted data.\n     * @param encoding - optional. Encoding for result output. May be 'buffer', 'json' or any of Node.js Buffer supported encoding.\n     * @returns {*}\n     */\n    NodeRSA.prototype.$getDecryptedData = function (buffer, encoding) {\n        encoding = encoding || 'buffer';\n\n        if (encoding == 'buffer') {\n            return buffer;\n        } else if (encoding == 'json') {\n            return JSON.parse(buffer.toString());\n        } else {\n            return buffer.toString(encoding);\n        }\n    };\n\n    return NodeRSA;\n})();\n"]},"metadata":{},"sourceType":"script"}