{"ast":null,"code":"/**\r\n * PSS signature scheme\r\n */\nvar BigInteger = require('../libs/jsbn');\n\nvar crypt = require('crypto');\n\nmodule.exports = {\n  isEncryption: false,\n  isSignature: true\n};\nvar DEFAULT_HASH_FUNCTION = 'sha1';\nvar DEFAULT_SALT_LENGTH = 20;\n\nmodule.exports.makeScheme = function (key, options) {\n  var OAEP = require('./schemes').pkcs1_oaep;\n  /**\r\n   * @param key\r\n   * @param options\r\n   * options    [Object]    An object that contains the following keys that specify certain options for encoding.\r\n   *  └>signingSchemeOptions\r\n   *     ├>hash    [String]    Hash function to use when encoding and generating masks. Must be a string accepted by node's crypto.createHash function. (default = \"sha1\")\r\n   *     ├>mgf    [function]    The mask generation function to use when encoding. (default = mgf1SHA1)\r\n   *     └>sLen    [uint]        The length of the salt to generate. (default = 20)\r\n   * @constructor\r\n   */\n\n\n  function Scheme(key, options) {\n    this.key = key;\n    this.options = options;\n  }\n\n  Scheme.prototype.sign = function (buffer) {\n    var mHash = crypt.createHash(this.options.signingSchemeOptions.hash || DEFAULT_HASH_FUNCTION);\n    mHash.update(buffer);\n    var encoded = this.emsa_pss_encode(mHash.digest(), this.key.keySize - 1);\n    return this.key.$doPrivate(new BigInteger(encoded)).toBuffer(this.key.encryptedDataLength);\n  };\n\n  Scheme.prototype.verify = function (buffer, signature, signature_encoding) {\n    if (signature_encoding) {\n      signature = Buffer.from(signature, signature_encoding);\n    }\n\n    signature = new BigInteger(signature);\n    var emLen = Math.ceil((this.key.keySize - 1) / 8);\n    var m = this.key.$doPublic(signature).toBuffer(emLen);\n    var mHash = crypt.createHash(this.options.signingSchemeOptions.hash || DEFAULT_HASH_FUNCTION);\n    mHash.update(buffer);\n    return this.emsa_pss_verify(mHash.digest(), m, this.key.keySize - 1);\n  };\n  /*\r\n   * https://tools.ietf.org/html/rfc3447#section-9.1.1\r\n   *\r\n   * mHash\t[Buffer]\tHashed message to encode\r\n   * emBits\t[uint]\t\tMaximum length of output in bits. Must be at least 8hLen + 8sLen + 9 (hLen = Hash digest length in bytes | sLen = length of salt in bytes)\r\n   * @returns {Buffer} The encoded message\r\n   */\n\n\n  Scheme.prototype.emsa_pss_encode = function (mHash, emBits) {\n    var hash = this.options.signingSchemeOptions.hash || DEFAULT_HASH_FUNCTION;\n    var mgf = this.options.signingSchemeOptions.mgf || OAEP.eme_oaep_mgf1;\n    var sLen = this.options.signingSchemeOptions.saltLength || DEFAULT_SALT_LENGTH;\n    var hLen = OAEP.digestLength[hash];\n    var emLen = Math.ceil(emBits / 8);\n\n    if (emLen < hLen + sLen + 2) {\n      throw new Error(\"Output length passed to emBits(\" + emBits + \") is too small for the options \" + \"specified(\" + hash + \", \" + sLen + \"). To fix this issue increase the value of emBits. (minimum size: \" + (8 * hLen + 8 * sLen + 9) + \")\");\n    }\n\n    var salt = crypt.randomBytes(sLen);\n    var Mapostrophe = Buffer.alloc(8 + hLen + sLen);\n    Mapostrophe.fill(0, 0, 8);\n    mHash.copy(Mapostrophe, 8);\n    salt.copy(Mapostrophe, 8 + mHash.length);\n    var H = crypt.createHash(hash);\n    H.update(Mapostrophe);\n    H = H.digest();\n    var PS = Buffer.alloc(emLen - salt.length - hLen - 2);\n    PS.fill(0);\n    var DB = Buffer.alloc(PS.length + 1 + salt.length);\n    PS.copy(DB);\n    DB[PS.length] = 0x01;\n    salt.copy(DB, PS.length + 1);\n    var dbMask = mgf(H, DB.length, hash); // XOR DB and dbMask together\n\n    var maskedDB = Buffer.alloc(DB.length);\n\n    for (var i = 0; i < dbMask.length; i++) {\n      maskedDB[i] = DB[i] ^ dbMask[i];\n    }\n\n    var bits = 8 * emLen - emBits;\n    var mask = 255 ^ 255 >> 8 - bits << 8 - bits;\n    maskedDB[0] = maskedDB[0] & mask;\n    var EM = Buffer.alloc(maskedDB.length + H.length + 1);\n    maskedDB.copy(EM, 0);\n    H.copy(EM, maskedDB.length);\n    EM[EM.length - 1] = 0xbc;\n    return EM;\n  };\n  /*\r\n   * https://tools.ietf.org/html/rfc3447#section-9.1.2\r\n   *\r\n   * mHash\t[Buffer]\tHashed message\r\n   * EM\t\t[Buffer]\tSignature\r\n   * emBits\t[uint]\t\tLength of EM in bits. Must be at least 8hLen + 8sLen + 9 to be a valid signature. (hLen = Hash digest length in bytes | sLen = length of salt in bytes)\r\n   * @returns {Boolean} True if signature(EM) matches message(M)\r\n   */\n\n\n  Scheme.prototype.emsa_pss_verify = function (mHash, EM, emBits) {\n    var hash = this.options.signingSchemeOptions.hash || DEFAULT_HASH_FUNCTION;\n    var mgf = this.options.signingSchemeOptions.mgf || OAEP.eme_oaep_mgf1;\n    var sLen = this.options.signingSchemeOptions.saltLength || DEFAULT_SALT_LENGTH;\n    var hLen = OAEP.digestLength[hash];\n    var emLen = Math.ceil(emBits / 8);\n\n    if (emLen < hLen + sLen + 2 || EM[EM.length - 1] != 0xbc) {\n      return false;\n    }\n\n    var DB = Buffer.alloc(emLen - hLen - 1);\n    EM.copy(DB, 0, 0, emLen - hLen - 1);\n    var mask = 0;\n\n    for (var i = 0, bits = 8 * emLen - emBits; i < bits; i++) {\n      mask |= 1 << 7 - i;\n    }\n\n    if ((DB[0] & mask) !== 0) {\n      return false;\n    }\n\n    var H = EM.slice(emLen - hLen - 1, emLen - 1);\n    var dbMask = mgf(H, DB.length, hash); // Unmask DB\n\n    for (i = 0; i < DB.length; i++) {\n      DB[i] ^= dbMask[i];\n    }\n\n    bits = 8 * emLen - emBits;\n    mask = 255 ^ 255 >> 8 - bits << 8 - bits;\n    DB[0] = DB[0] & mask; // Filter out padding\n\n    for (i = 0; DB[i] === 0 && i < DB.length; i++);\n\n    if (DB[i] != 1) {\n      return false;\n    }\n\n    var salt = DB.slice(DB.length - sLen);\n    var Mapostrophe = Buffer.alloc(8 + hLen + sLen);\n    Mapostrophe.fill(0, 0, 8);\n    mHash.copy(Mapostrophe, 8);\n    salt.copy(Mapostrophe, 8 + mHash.length);\n    var Hapostrophe = crypt.createHash(hash);\n    Hapostrophe.update(Mapostrophe);\n    Hapostrophe = Hapostrophe.digest();\n    return H.toString(\"hex\") === Hapostrophe.toString(\"hex\");\n  };\n\n  return new Scheme(key, options);\n};","map":{"version":3,"sources":["C:/Users/Zaman/zaman/RSA/front/node_modules/node-rsa/src/schemes/pss.js"],"names":["BigInteger","require","crypt","module","exports","isEncryption","isSignature","DEFAULT_HASH_FUNCTION","DEFAULT_SALT_LENGTH","makeScheme","key","options","OAEP","pkcs1_oaep","Scheme","prototype","sign","buffer","mHash","createHash","signingSchemeOptions","hash","update","encoded","emsa_pss_encode","digest","keySize","$doPrivate","toBuffer","encryptedDataLength","verify","signature","signature_encoding","Buffer","from","emLen","Math","ceil","m","$doPublic","emsa_pss_verify","emBits","mgf","eme_oaep_mgf1","sLen","saltLength","hLen","digestLength","Error","salt","randomBytes","Mapostrophe","alloc","fill","copy","length","H","PS","DB","dbMask","maskedDB","i","bits","mask","EM","slice","Hapostrophe","toString"],"mappings":"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","sourcesContent":["/**\r\n * PSS signature scheme\r\n */\r\n\r\nvar BigInteger = require('../libs/jsbn');\r\nvar crypt = require('crypto');\r\n\r\nmodule.exports = {\r\n    isEncryption: false,\r\n    isSignature: true\r\n};\r\n\r\nvar DEFAULT_HASH_FUNCTION = 'sha1';\r\nvar DEFAULT_SALT_LENGTH = 20;\r\n\r\nmodule.exports.makeScheme = function (key, options) {\r\n    var OAEP = require('./schemes').pkcs1_oaep;\r\n\r\n    /**\r\n     * @param key\r\n     * @param options\r\n     * options    [Object]    An object that contains the following keys that specify certain options for encoding.\r\n     *  └>signingSchemeOptions\r\n     *     ├>hash    [String]    Hash function to use when encoding and generating masks. Must be a string accepted by node's crypto.createHash function. (default = \"sha1\")\r\n     *     ├>mgf    [function]    The mask generation function to use when encoding. (default = mgf1SHA1)\r\n     *     └>sLen    [uint]        The length of the salt to generate. (default = 20)\r\n     * @constructor\r\n     */\r\n    function Scheme(key, options) {\r\n        this.key = key;\r\n        this.options = options;\r\n    }\r\n\r\n    Scheme.prototype.sign = function (buffer) {\r\n        var mHash = crypt.createHash(this.options.signingSchemeOptions.hash || DEFAULT_HASH_FUNCTION);\r\n        mHash.update(buffer);\r\n\r\n        var encoded = this.emsa_pss_encode(mHash.digest(), this.key.keySize - 1);\r\n        return this.key.$doPrivate(new BigInteger(encoded)).toBuffer(this.key.encryptedDataLength);\r\n    };\r\n\r\n    Scheme.prototype.verify = function (buffer, signature, signature_encoding) {\r\n        if (signature_encoding) {\r\n            signature = Buffer.from(signature, signature_encoding);\r\n        }\r\n        signature = new BigInteger(signature);\r\n\r\n        var emLen = Math.ceil((this.key.keySize - 1) / 8);\r\n        var m = this.key.$doPublic(signature).toBuffer(emLen);\r\n\r\n        var mHash = crypt.createHash(this.options.signingSchemeOptions.hash || DEFAULT_HASH_FUNCTION);\r\n        mHash.update(buffer);\r\n\r\n        return this.emsa_pss_verify(mHash.digest(), m, this.key.keySize - 1);\r\n    };\r\n\r\n    /*\r\n     * https://tools.ietf.org/html/rfc3447#section-9.1.1\r\n     *\r\n     * mHash\t[Buffer]\tHashed message to encode\r\n     * emBits\t[uint]\t\tMaximum length of output in bits. Must be at least 8hLen + 8sLen + 9 (hLen = Hash digest length in bytes | sLen = length of salt in bytes)\r\n     * @returns {Buffer} The encoded message\r\n     */\r\n    Scheme.prototype.emsa_pss_encode = function (mHash, emBits) {\r\n        var hash = this.options.signingSchemeOptions.hash || DEFAULT_HASH_FUNCTION;\r\n        var mgf = this.options.signingSchemeOptions.mgf || OAEP.eme_oaep_mgf1;\r\n        var sLen = this.options.signingSchemeOptions.saltLength || DEFAULT_SALT_LENGTH;\r\n\r\n        var hLen = OAEP.digestLength[hash];\r\n        var emLen = Math.ceil(emBits / 8);\r\n\r\n        if (emLen < hLen + sLen + 2) {\r\n            throw new Error(\"Output length passed to emBits(\" + emBits + \") is too small for the options \" +\r\n                \"specified(\" + hash + \", \" + sLen + \"). To fix this issue increase the value of emBits. (minimum size: \" +\r\n                (8 * hLen + 8 * sLen + 9) + \")\"\r\n            );\r\n        }\r\n\r\n        var salt = crypt.randomBytes(sLen);\r\n\r\n        var Mapostrophe = Buffer.alloc(8 + hLen + sLen);\r\n        Mapostrophe.fill(0, 0, 8);\r\n        mHash.copy(Mapostrophe, 8);\r\n        salt.copy(Mapostrophe, 8 + mHash.length);\r\n\r\n        var H = crypt.createHash(hash);\r\n        H.update(Mapostrophe);\r\n        H = H.digest();\r\n\r\n        var PS = Buffer.alloc(emLen - salt.length - hLen - 2);\r\n        PS.fill(0);\r\n\r\n        var DB = Buffer.alloc(PS.length + 1 + salt.length);\r\n        PS.copy(DB);\r\n        DB[PS.length] = 0x01;\r\n        salt.copy(DB, PS.length + 1);\r\n\r\n        var dbMask = mgf(H, DB.length, hash);\r\n\r\n        // XOR DB and dbMask together\r\n        var maskedDB = Buffer.alloc(DB.length);\r\n        for (var i = 0; i < dbMask.length; i++) {\r\n            maskedDB[i] = DB[i] ^ dbMask[i];\r\n        }\r\n\r\n        var bits = 8 * emLen - emBits;\r\n        var mask = 255 ^ (255 >> 8 - bits << 8 - bits);\r\n        maskedDB[0] = maskedDB[0] & mask;\r\n\r\n        var EM = Buffer.alloc(maskedDB.length + H.length + 1);\r\n        maskedDB.copy(EM, 0);\r\n        H.copy(EM, maskedDB.length);\r\n        EM[EM.length - 1] = 0xbc;\r\n\r\n        return EM;\r\n    };\r\n\r\n    /*\r\n     * https://tools.ietf.org/html/rfc3447#section-9.1.2\r\n     *\r\n     * mHash\t[Buffer]\tHashed message\r\n     * EM\t\t[Buffer]\tSignature\r\n     * emBits\t[uint]\t\tLength of EM in bits. Must be at least 8hLen + 8sLen + 9 to be a valid signature. (hLen = Hash digest length in bytes | sLen = length of salt in bytes)\r\n     * @returns {Boolean} True if signature(EM) matches message(M)\r\n     */\r\n    Scheme.prototype.emsa_pss_verify = function (mHash, EM, emBits) {\r\n        var hash = this.options.signingSchemeOptions.hash || DEFAULT_HASH_FUNCTION;\r\n        var mgf = this.options.signingSchemeOptions.mgf || OAEP.eme_oaep_mgf1;\r\n        var sLen = this.options.signingSchemeOptions.saltLength || DEFAULT_SALT_LENGTH;\r\n\r\n        var hLen = OAEP.digestLength[hash];\r\n        var emLen = Math.ceil(emBits / 8);\r\n\r\n        if (emLen < hLen + sLen + 2 || EM[EM.length - 1] != 0xbc) {\r\n            return false;\r\n        }\r\n\r\n        var DB = Buffer.alloc(emLen - hLen - 1);\r\n        EM.copy(DB, 0, 0, emLen - hLen - 1);\r\n\r\n        var mask = 0;\r\n        for (var i = 0, bits = 8 * emLen - emBits; i < bits; i++) {\r\n            mask |= 1 << (7 - i);\r\n        }\r\n\r\n        if ((DB[0] & mask) !== 0) {\r\n            return false;\r\n        }\r\n\r\n        var H = EM.slice(emLen - hLen - 1, emLen - 1);\r\n        var dbMask = mgf(H, DB.length, hash);\r\n\r\n        // Unmask DB\r\n        for (i = 0; i < DB.length; i++) {\r\n            DB[i] ^= dbMask[i];\r\n        }\r\n\r\n        bits = 8 * emLen - emBits;\r\n        mask = 255 ^ (255 >> 8 - bits << 8 - bits);\r\n        DB[0] = DB[0] & mask;\r\n\r\n        // Filter out padding\r\n        for (i = 0; DB[i] === 0 && i < DB.length; i++);\r\n        if (DB[i] != 1) {\r\n            return false;\r\n        }\r\n\r\n        var salt = DB.slice(DB.length - sLen);\r\n\r\n        var Mapostrophe = Buffer.alloc(8 + hLen + sLen);\r\n        Mapostrophe.fill(0, 0, 8);\r\n        mHash.copy(Mapostrophe, 8);\r\n        salt.copy(Mapostrophe, 8 + mHash.length);\r\n\r\n        var Hapostrophe = crypt.createHash(hash);\r\n        Hapostrophe.update(Mapostrophe);\r\n        Hapostrophe = Hapostrophe.digest();\r\n\r\n        return H.toString(\"hex\") === Hapostrophe.toString(\"hex\");\r\n    };\r\n\r\n    return new Scheme(key, options);\r\n};\r\n"]},"metadata":{},"sourceType":"script"}